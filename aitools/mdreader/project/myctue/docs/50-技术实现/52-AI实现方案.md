---
文档编号: 52
文档名称: AI实现方案
版本: 1.0
最后更新: 2025-10-28
---

# AI实现方案

## 文档元信息
- **所属类别**: 技术实现
- **依赖文档**: [桌宠AI与需求系统](../10-核心系统/11-桌宠AI与需求系统.md)、[架构设计](51-架构设计.md)
- **相关文档**: [情感与记忆系统](../30-扩展系统/31-情感与记忆系统.md)

## 相关文档链接
- **上级文档**: [项目总览与导航](../00-规划/00-项目总览与导航.md)
- **同级文档**: [架构设计](51-架构设计.md)、[数据结构设计](50-数据结构设计.md)
- **下级文档**: 无

---

## 1. AI系统概述

### 1.1 AI设计目标

```
桌宠AI核心目标:
├─ 自主性: 桌宠能独立做出合理决策
├─ 可信性: 行为符合逻辑和性格设定
├─ 多样性: 不同个体有不同行为模式
├─ 可预测性: 玩家能理解桌宠的行为动机
└─ 趣味性: 产生有趣和意外的互动
```

### 1.2 AI架构选型

```javascript
AI技术方案:
{
  "核心算法": "效用理论 (Utility Theory)",
  "辅助技术": [
    "决策树 (Decision Tree)",
    "行为树 (Behavior Tree)",
    "状态机 (State Machine)",
    "目标导向行动计划 (GOAP)"
  ],
  "不使用": "深度学习/神经网络",
  "原因": "可解释性强、资源消耗低、行为可控"
}
```

---

## 2. 效用理论实现

### 2.1 效用函数设计

```typescript
/**
 * 效用计算核心实现
 */

interface UtilityContext {
  pet: Pet;
  action: Action;
  worldState: WorldState;
  timestamp: number;
}

class UtilitySystem {
  /**
   * 主效用计算函数
   */
  public calculateUtility(context: UtilityContext): number {
    const scores = {
      needs: this.calculateNeedsUtility(context),
      emotions: this.calculateEmotionalUtility(context),
      personality: this.calculatePersonalityUtility(context),
      social: this.calculateSocialUtility(context),
      goals: this.calculateGoalUtility(context),
      curiosity: this.calculateCuriosityUtility(context)
    };
    
    // 加权求和
    const weights = this.getWeights(context.pet);
    const totalUtility = 
      scores.needs * weights.needs +
      scores.emotions * weights.emotions +
      scores.personality * weights.personality +
      scores.social * weights.social +
      scores.goals * weights.goals +
      scores.curiosity * weights.curiosity;
    
    return totalUtility;
  }
  
  /**
   * 需求满足效用
   */
  private calculateNeedsUtility(context: UtilityContext): number {
    const { pet, action } = context;
    let utility = 0;
    
    // 遍历所有需求
    for (const [needType, currentValue] of Object.entries(pet.needs)) {
      // 预测行动对需求的影响
      const predictedChange = action.predictNeedChange(needType);
      const urgency = this.calculateNeedUrgency(currentValue);
      
      // 如果需求紧急且行动能满足,效用高
      if (currentValue < 30 && predictedChange > 0) {
        utility += urgency * predictedChange * 2;
      }
      // 如果需求已满足但行动还要增加,效用低
      else if (currentValue > 80 && predictedChange > 0) {
        utility -= predictedChange * 0.5;
      }
      // 正常情况
      else {
        utility += urgency * predictedChange;
      }
    }
    
    return utility;
  }
  
  /**
   * 需求紧急度计算 (0-1)
   */
  private calculateNeedUrgency(currentValue: number): number {
    // 使用反比例函数,越低越紧急
    // urgency = 100 / (currentValue + 10)
    // 范围映射到 0-1
    const rawUrgency = 100 / (currentValue + 10);
    return Math.min(rawUrgency / 10, 1);
  }
  
  /**
   * 情感影响效用
   */
  private calculateEmotionalUtility(context: UtilityContext): number {
    const { pet, action } = context;
    let utility = 0;
    
    // 快乐度高时,更倾向娱乐活动
    if (pet.emotions.joy > 70) {
      if (action.tags.includes('fun') || action.tags.includes('social')) {
        utility += 20;
      }
    }
    
    // 悲伤度高时,倾向独处或寻求安慰
    if (pet.emotions.sadness > 60) {
      if (action.tags.includes('solitude')) {
        utility += 15;
      }
      if (action.tags.includes('comfort')) {
        utility += 25;
      }
    }
    
    // 愤怒度高时,倾向发泄
    if (pet.emotions.anger > 50) {
      if (action.tags.includes('vent') || action.tags.includes('exercise')) {
        utility += 20;
      }
      // 避免社交
      if (action.tags.includes('social')) {
        utility -= 15;
      }
    }
    
    // 恐惧度高时,避免冒险
    if (pet.emotions.fear > 50) {
      if (action.tags.includes('safe')) {
        utility += 15;
      }
      if (action.tags.includes('risky')) {
        utility -= 30;
      }
    }
    
    return utility;
  }
  
  /**
   * 性格匹配效用
   */
  private calculatePersonalityUtility(context: UtilityContext): number {
    const { pet, action } = context;
    let utility = 0;
    
    // 外向性
    if (pet.personality.extraversion > 60) {
      if (action.tags.includes('social')) utility += 15;
      if (action.tags.includes('solitude')) utility -= 10;
    } else if (pet.personality.extraversion < 40) {
      if (action.tags.includes('solitude')) utility += 15;
      if (action.tags.includes('social')) utility -= 10;
    }
    
    // 开放性
    if (pet.personality.openness > 60) {
      if (action.tags.includes('explore') || action.tags.includes('learn')) {
        utility += 12;
      }
    }
    
    // 尽责性
    if (pet.personality.conscientiousness > 60) {
      if (action.tags.includes('work') || action.tags.includes('organize')) {
        utility += 10;
      }
    }
    
    // 神经质
    if (pet.personality.neuroticism > 60) {
      if (action.tags.includes('safe')) utility += 8;
      if (action.tags.includes('risky')) utility -= 15;
    }
    
    return utility;
  }
  
  /**
   * 社交关系效用
   */
  private calculateSocialUtility(context: UtilityContext): number {
    const { pet, action, worldState } = context;
    let utility = 0;
    
    // 如果是社交行动
    if (action.type === 'social') {
      const target = action.target;
      const relationship = pet.relationships.get(target);
      
      if (relationship) {
        // 关系好,更愿意互动
        if (relationship.affection > 60) {
          utility += relationship.affection / 5;
        }
        // 关系差,避免互动
        if (relationship.affection < 30) {
          utility -= (30 - relationship.affection) / 2;
        }
      }
    }
    
    // 孤独时间过长,增加社交意愿
    const timeSinceLastSocial = worldState.currentTime - pet.lastSocialTime;
    if (timeSinceLastSocial > 3600000) { // 1小时
      if (action.tags.includes('social')) {
        utility += Math.min(timeSinceLastSocial / 360000, 20);
      }
    }
    
    return utility;
  }
  
  /**
   * 目标进度效用
   */
  private calculateGoalUtility(context: UtilityContext): number {
    const { pet, action } = context;
    let utility = 0;
    
    // 如果桌宠有活跃目标
    if (pet.currentGoal) {
      const goal = pet.currentGoal;
      
      // 行动能推进目标
      if (action.contributes(goal)) {
        utility += 25;
        
        // 目标接近完成,效用更高
        const progress = goal.getProgress();
        if (progress > 0.7) {
          utility += 15;
        }
      }
    }
    
    return utility;
  }
  
  /**
   * 好奇心/探索效用
   */
  private calculateCuriosityUtility(context: UtilityContext): number {
    const { pet, action } = context;
    let utility = 0;
    
    // 新事物吸引力
    if (action.isNew && pet.personality.openness > 50) {
      utility += 10 + (pet.personality.openness - 50) / 5;
    }
    
    // 重复行动疲劳
    const recentActionCount = pet.recentActions.filter(
      a => a.type === action.type
    ).length;
    
    if (recentActionCount > 3) {
      utility -= recentActionCount * 3;
    }
    
    return utility;
  }
  
  /**
   * 获取权重配置
   */
  private getWeights(pet: Pet): UtilityWeights {
    // 基础权重
    const baseWeights = {
      needs: 0.35,
      emotions: 0.20,
      personality: 0.15,
      social: 0.15,
      goals: 0.10,
      curiosity: 0.05
    };
    
    // 根据生命阶段调整
    if (pet.lifeStage === 'childhood') {
      return {
        ...baseWeights,
        needs: 0.45,  // 幼年更关注需求
        curiosity: 0.15  // 好奇心更强
      };
    }
    
    if (pet.lifeStage === 'adult') {
      return {
        ...baseWeights,
        goals: 0.20,  // 成年更关注目标
        needs: 0.25
      };
    }
    
    return baseWeights;
  }
}
```

### 2.2 行动选择算法

```typescript
/**
 * 行动选择器
 */
class ActionSelector {
  private utilitySystem: UtilitySystem;
  
  /**
   * 选择最佳行动
   */
  public selectAction(
    pet: Pet,
    availableActions: Action[],
    worldState: WorldState
  ): Action {
    // 1. 过滤不可执行的行动
    const executableActions = availableActions.filter(action =>
      action.canExecute(pet, worldState)
    );
    
    if (executableActions.length === 0) {
      return this.getIdleAction();
    }
    
    // 2. 计算每个行动的效用
    const actionScores = executableActions.map(action => ({
      action,
      utility: this.utilitySystem.calculateUtility({
        pet,
        action,
        worldState,
        timestamp: Date.now()
      })
    }));
    
    // 3. 按效用排序
    actionScores.sort((a, b) => b.utility - a.utility);
    
    // 4. 添加随机性(前N个高分行动中随机选择)
    const topN = Math.min(3, actionScores.length);
    const topActions = actionScores.slice(0, topN);
    
    // 使用softmax选择(效用高的概率大,但不是100%)
    const selectedAction = this.softmaxSelection(topActions);
    
    return selectedAction;
  }
  
  /**
   * Softmax选择算法
   */
  private softmaxSelection(
    actionScores: Array<{action: Action, utility: number}>
  ): Action {
    // 计算softmax概率
    const temperature = 10; // 温度参数,越小越确定性
    const expScores = actionScores.map(item => ({
      action: item.action,
      prob: Math.exp(item.utility / temperature)
    }));
    
    const totalProb = expScores.reduce((sum, item) => sum + item.prob, 0);
    const probabilities = expScores.map(item => ({
      action: item.action,
      prob: item.prob / totalProb
    }));
    
    // 轮盘赌选择
    const rand = Math.random();
    let cumulative = 0;
    
    for (const item of probabilities) {
      cumulative += item.prob;
      if (rand <= cumulative) {
        return item.action;
      }
    }
    
    return probabilities[0].action;
  }
  
  private getIdleAction(): Action {
    return new IdleAction();
  }
}
```

---

## 3. 行为树实现

### 3.1 行为树节点定义

```typescript
/**
 * 行为树基础节点
 */
abstract class BehaviorNode {
  abstract execute(context: BTContext): BTNodeStatus;
}

enum BTNodeStatus {
  SUCCESS = 'success',
  FAILURE = 'failure',
  RUNNING = 'running'
}

interface BTContext {
  pet: Pet;
  worldState: WorldState;
  blackboard: Map<string, any>;
}

/**
 * 复合节点
 */

// 顺序节点 - 按顺序执行子节点
class SequenceNode extends BehaviorNode {
  private children: BehaviorNode[];
  private currentIndex: number = 0;
  
  execute(context: BTContext): BTNodeStatus {
    while (this.currentIndex < this.children.length) {
      const child = this.children[this.currentIndex];
      const status = child.execute(context);
      
      if (status === BTNodeStatus.FAILURE) {
        this.currentIndex = 0;
        return BTNodeStatus.FAILURE;
      }
      
      if (status === BTNodeStatus.RUNNING) {
        return BTNodeStatus.RUNNING;
      }
      
      // SUCCESS,继续下一个
      this.currentIndex++;
    }
    
    this.currentIndex = 0;
    return BTNodeStatus.SUCCESS;
  }
}

// 