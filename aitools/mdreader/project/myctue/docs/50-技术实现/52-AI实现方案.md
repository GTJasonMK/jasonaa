
# 52-AI实现方案

> **文档版本**: v2.1 (Godot + C#适配版)
> **最后更新**: 2025-11-01
> **技术栈**: Godot 4.x + C#
> **负责人**: 待定
> **优先级**: ⭐⭐⭐⭐⭐ (核心技术)
> **实现版本**: MVP v1.0+

---

## 📋 相关文档

**前置依赖**:
- [11-桌宠AI与需求系统](../10-核心系统/11-桌宠AI与需求系统.md) - AI设计需求
- [51-架构设计](./51-架构设计.md) - 系统架构基础
- [50-数据结构设计](./50-数据结构设计.md) - 数据模型

**相关文档**:
- [30-个性化系统](../30-扩展系统/30-个性化系统.md) - 性格特质
- [31-情感与记忆系统](../30-扩展系统/31-情感与记忆系统.md) - 情感模型
- [32-关系系统](../30-扩展系统/32-关系系统.md) - 社交决策
- [15-任务系统](../10-核心系统/15-任务系统.md) - 任务执行AI
- [07-术语表](../00-规划/07-术语表与概念定义.md) - 术语定义

---

## 一、AI系统概述与定位

### 1.1 设计理念

《我的Ctue》的AI系统不是传统游戏中的"敌人AI"或"战斗AI"，而是一个**生命模拟AI**，核心目标是创造一个：

- **可信的虚拟生命**：桌宠的行为应该让玩家感觉"它真的在思考"
- **有温度的陪伴者**：不是工具，而是有性格、有情感的伙伴
- **自主的决策者**：能在没有玩家干预的情况下独立生活
- **可理解的个体**：玩家能通过观察理解桌宠的行为动机

### 1.2 AI在项目中的角色定位

```yaml
AI系统职责划分:
  核心职责:
    - 桌宠自主决策: 选择下一步做什么（种植/钓鱼/休息/供奉等）
    - 需求管理: 监控并响应五大需求（饥饿/疲劳/快乐/健康/虔诚）
    - 情感表达: 根据情绪状态选择适当的动画和对话
    - 社交互动: 与玩家和NPC建立和维护关系
    - 任务执行: 智能地执行玩家委托的现实任务
  
  次要职责:
    - 学习规划: 决定学习哪些工具书和技能
    - 供奉决策: 选择合适的物品和时机进行供奉
    - 资源管理: 平衡自用、出售、供奉三种资源分配
    - 目标追求: 追求长期目标（如成为工匠、探索者等）
  
  不负责的部分:
    - 玩家操作: 玩家保留完全的神力控制权
    - 战斗AI: 本项目无战斗系统
    - 程序生成: 世界内容由设计师预设，非AI生成
```

### 1.3 关键设计挑战

**挑战1：平衡自主性与可控性**
- 问题：桌宠太自主会让玩家失去掌控感，太机械又失去生命感
- 方案：通过神力系统提供"间接影响"机制，玩家不直接控制但能引导

**挑战2：保持行为的多样性与合理性**
- 问题：重复的行为模式会让AI显得呆板
- 方案：多层决策系统 + 随机性注入 + 记忆系统避免重复

**挑战3：性能与复杂度的权衡**
- 问题：复杂的AI计算可能影响游戏性能
- 方案：分层架构 + 异步决策 + 缓存机制

**挑战4：AI行为的可解释性**
- 问题：玩家需要理解"桌宠为什么这么做"
- 方案：UI显示思考气泡 + 对话系统解释动机

---

## 二、AI架构设计

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    表现层 (Presentation)                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  动画控制   │  │  对话生成   │  │  UI反馈     │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              ↑
┌─────────────────────────────────────────────────────────────┐
│                    执行层 (Execution)                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  行为树     │  │  动作系统   │  │  寻路系统   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              ↑
┌─────────────────────────────────────────────────────────────┐
│                    决策层 (Decision)                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  效用系统   │  │  目标管理   │  │  计划系统   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              ↑
┌─────────────────────────────────────────────────────────────┐
│                    感知层 (Perception)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  需求监控   │  │  环境感知   │  │  记忆查询   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              ↑
┌─────────────────────────────────────────────────────────────┐
│                    数据层 (Data)                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  需求值  │  │  情绪值  │  │  记忆库  │  │  世界状态│   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 各层职责详解

#### 2.2.1 感知层 (Perception Layer)

**功能**：收集和处理桌宠可感知的信息

```csharp
using Godot;
using System.Collections.Generic;

/// <summary>
/// 感知系统 - AI的"感官"
/// </summary>
public partial class PerceptionSystem : Node
{
  private Pet _pet;
  private WorldState _worldState;
  
  /// <summary>
  /// 感知更新（每帧或定时调用）
  /// </summary>
  public PerceptionData Update(double deltaTime)
  {
    return new PerceptionData
    {
      // 内部感知：自身状态
      InternalState = PerceiveInternalState(),
      
      // 环境感知：周围世界
      Environment = PerceiveEnvironment(),
      
      // 社交感知：他人状态
      Social = PerceiveSocialContext(),
      
      // 时间感知：时间相关信息
      Temporal = PerceiveTime(),
      
      // 记忆检索：相关历史
      Memories = RetrieveRelevantMemories()
    };
  }
  
  /// <summary>
  /// 内部状态感知
  /// </summary>
  private InternalPerception PerceiveInternalState()
  {
    var needs = _pet.Needs;
    
    return new InternalPerception
    {
      // 需求紧急程度排序
      UrgentNeeds = RankNeedsByUrgency(needs),
      
      // 当前情绪状态
      EmotionalState = _pet.Emotions,
      
      // 体力状态
      EnergyLevel = needs.Fatigue,
      
      // 技能状况
      Skills = _pet.Skills,
      
      // 仓库状态
      Inventory = new InventoryPerception
      {
        Items = _pet.Inventory,
        SpaceUsed = _pet.Inventory.Count,
        SpaceTotal = _pet.InventoryCapacity
      },
      
      // 活跃目标
      ActiveGoals = _pet.Goals.Where(g => g.IsActive).ToList()
    };
  }
  
  /**
   * 环境感知
   */
  private perceiveEnvironment(): EnvironmentPerception {
    const currentScene = this.worldState.currentScene;
    
    return {
      // 当前场景
      location: currentScene.type,
      
      // 天气状况
      weather: this.worldState.weather,
      
      // 时段（早晨/中午/夜晚）
      timeOfDay: this.worldState.timeOfDay,
      
      // 可交互对象
      interactables: currentScene.getInteractablesInRange(
        this.pet.position,
        this.pet.perceptionRadius
      ),
      
      // 附近NPC
      nearbyNPCs: currentScene.getNPCsInRange(
        this.pet.position,
        this.pet.socialPerceptionRadius
      ),
      
      // 场景特殊状态（如作物成熟、鱼上钩等）
      sceneEvents: currentScene.getActiveEvents()
    };
  }
  
  /**
   * 社交感知
   */
  private perceiveSocialContext(): SocialPerception {
    return {
      // 与玩家的关系
      playerRelationship: this.pet.relationships.get('player'),
      
      // 最近一次互动时间
      timeSinceLastInteraction: 
        Date.now() - this.pet.lastInteractionTime,
      
      // 待响应的祈祷
      pendingPrayers: this.pet.pendingPrayers,
      
      // 附近NPC的情绪
      nearbyEmotions: this.perceiveNearbyEmotions()
    };
  }
  
  /**
   * 时间感知
   */
  private perceiveTime(): TemporalPerception {
    return {
      // 活动时间（游戏时间）
      activityTime: this.worldState.activityTime,
      
      // 生命时间（真实时间）
      lifeTime: this.worldState.lifeTime,
      
      // 年龄
      age: this.pet.age,
      
      // 生命阶段
      lifeStage: this.pet.lifeStage,
      
      // 季节
      season: this.worldState.season,
      
      

// 节日状态
      specialEvents: this.worldState.activeEvents
    };
  }
  
  /**
   * 检索相关记忆
   */
  private retrieveRelevantMemories(): Memory[] {
    const currentContext = {
      location: this.worldState.currentScene.type,
      timeOfDay: this.worldState.timeOfDay,
      recentActions: this.pet.recentActions
    };
    
    // 检索与当前情境相关的记忆
    return this.pet.memorySystem.retrieve(currentContext, 5);
  }
  
  /**
   * 需求紧急度排序
   */
  private rankNeedsByUrgency(needs: Needs): Array<{type: string, urgency: number}> {
    const needTypes = ['hunger', 'fatigue', 'happiness', 'health', 'devotion'];
    
    return needTypes.map(type => ({
      type,
      value: needs[type],
      urgency: this.calculateUrgency(needs[type], type)
    }))
    .sort((a, b) => b.urgency - a.urgency);
  }
  
  /**
   * 紧急度计算公式
   */
  private calculateUrgency(value: number, type: string): number {
    // 使用反比例函数，值越低越紧急
    const urgency = 100 / (value + 10);
    
    // 不同需求有不同的紧急度权重
    const weights = {
      hunger: 1.2,    // 饥饿最紧急
      health: 1.1,    // 健康次之
      fatigue: 1.0,
      happiness: 0.8,
      devotion: 0.6   // 虔诚度相对不紧急
    };
    
    return urgency * (weights[type] || 1.0);
  }
}
```

#### 2.2.2 决策层 (Decision Layer)

**功能**：基于感知信息做出行动决策

```csharp
/// <summary>
/// 决策系统 - AI的"大脑"
/// </summary>
public partial class DecisionSystem : Node
{
  private UtilitySystem _utilitySystem;
  private GoalManager _goalManager;
  private PlanningSystem _planningSystem;
  
  /// <summary>
  /// 主决策函数
  /// </summary>
  public Decision MakeDecision(PerceptionData perception)
  {
    // 1. 紧急情况检测（优先级最高）
    var emergency = DetectEmergency(perception);
    if (emergency != null)
    {
      return MakeEmergencyDecision(emergency);
    }
    
    // 2. 目标驱动决策
    if (perception.InternalState.ActiveGoals.Count > 0)
    {
      var goalBasedDecision = MakeGoalBasedDecision(perception);
      if (goalBasedDecision.Priority > 0.7f)
      {
        return goalBasedDecision;
      }
    }
    
    // 3. 效用驱动决策（日常行为）
    return MakeUtilityBasedDecision(perception);
  }
  
  /**
   * 紧急情况检测
   */
  private detectEmergency(perception: PerceptionData): Emergency | null {
    const needs = perception.internalState.urgentNeeds;
    
    // 任何需求低于20为紧急情况
    for (const need of needs) {
      if (need.value < 20) {
        return {
          type: 'critical_need',
          needType: need.type,
          severity: 1.0 - (need.value / 20)
        };
      }
    }
    
    // 健康度低于30且持续下降
    if (perception.internalState.energyLevel < 30 && 
        this.isNeedDecreasing('health')) {
      return {
        type: 'health_crisis',
        severity: 0.8
      };
    }
    
    return null;
  }
  
  /**
   * 紧急决策
   */
  private makeEmergencyDecision(emergency: Emergency): Decision {
    switch (emergency.type) {
      case 'critical_need':
        // 立即寻找满足需求的行动
        return this.findNeedSatisfyingAction(emergency.needType);
        
      case 'health_crisis':
        // 立即休息或寻求治疗
        return {
          action: 'rest',
          priority: 1.0,
          reason: '健康危机，需要立即休息'
        };
        
      default:
        return this.getDefaultAction();
    }
  }
  
  /**
   * 目标驱动决策
   */
  private makeGoalBasedDecision(perception: PerceptionData): Decision {
    const activeGoal = perception.internalState.activeGoals[0];
    
    // 使用GOAP（目标导向行动计划）算法
    const plan = this.planningSystem.planForGoal(
      activeGoal,
      perception
    );
    
    if (plan && plan.actions.length > 0) {
      return {
        action: plan.actions[0],
        priority: 0.8,
        reason: `为了实现目标: ${activeGoal.name}`,
        plannedSequence: plan.actions
      };
    }
    
    return null;
  }
  
  /**
   * 效用驱动决策（核心算法）
   */
  private makeUtilityBasedDecision(perception: PerceptionData): Decision {
    // 获取所有可执行的行动
    const availableActions = this.getAvailableActions(perception);
    
    // 计算每个行动的效用值
    const actionScores = availableActions.map(action => ({
      action,
      utility: this.utilitySystem.calculateUtility(action, perception),
      reasoning: this.utilitySystem.getReasoningBreakdown(action, perception)
    }));
    
    // 排序并选择
    actionScores.sort((a, b) => b.utility - a.utility);
    
    // 添加随机性（softmax选择）
    const selected = this.softmaxSelection(actionScores.slice(0, 3));
    
    return {
      action: selected.action,
      priority: selected.utility / 100, // 归一化到0-1
      reason: this.generateReasoningText(selected.reasoning),
      alternatives: actionScores.slice(0, 3).map(s => s.action)
    };
  }
  
  /**
   * Softmax选择（增加行为多样性）
   */
  private softmaxSelection(
    candidates: Array<{action: Action, utility: number}>
  ): {action: Action, utility: number} {
    const temperature = 15; // 温度参数，控制随机性
    
    const expScores = candidates.map(c => ({
      action: c.action,
      utility: c.utility,
      prob: Math.exp(c.utility / temperature)
    }));
    
    const totalProb = expScores.reduce((sum, item) => sum + item.prob, 0);
    const rand = Math.random() * totalProb;
    
    let cumulative = 0;
    for (const item of expScores) {
      cumulative += item.prob;
      if (rand <= cumulative) {
        return {action: item.action, utility: item.utility};
      }
    }
    
    return {action: candidates[0].action, utility: candidates[0].utility};
  }
}
```

#### 2.2.3 执行层 (Execution Layer)

**功能**：将决策转化为具体的行为序列

```csharp
/// <summary>
/// 执行系统 - AI的"身体"
/// </summary>
public partial class ExecutionSystem : Node
{
  private BehaviorTree _behaviorTree;
  private ActionExecutor _actionExecutor;
  private PathfindingSystem _pathfinding;
  
  /**
   * 执行决策
   */
  public async executeDecision(decision: Decision, pet: Pet): Promise<ExecutionResult> {
    // 1. 分解为行为树
    const behaviorTree = this.buildBehaviorTree(decision);
    
    // 2. 执行行为树
    const result = await this.executeBehaviorTree(behaviorTree, pet);
    
    // 3. 记录执行结果
    this.recordExecution(decision, result, pet);
    
    return result;
  }
  
  /**
   * 构建行为树
   */
  private buildBehaviorTree(decision: Decision): BehaviorTree {
    const action = decision.action;
    
    // 根据行动类型构建不同的行为树
    switch (action.type) {
      case 'harvest_crop':
        return new SequenceNode([
          new NavigateToNode(action.target),
          new PlayAnimationNode('bend_down'),
          new HarvestNode(action.target),
          new PlayAnimationNode('stand_up'),
          new AddToInventoryNode(action.harvestedItem)
        ]);
        
      case 'go_fishing':
        return new SequenceNode([
          new NavigateToNode(action.location),
          new EquipToolNode('fishing_rod'),
          new PlayAnimationNode('cast_line'),
          new WaitForBiteNode({timeout: 60000}),
          new SelectorNode([
            new SequenceNode([
              new CheckBiteNode(),
              new PlayAnimationNode('reel_in'),
              new CatchFishNode(),
              new AddToInventoryNode('fish')
            ]),
            new PlayAnimationNode('disappointed')
          ])
        ]);
        
      case 'make_offering':
        return new SequenceNode([
          new SelectOfferingItemNode(),
          new NavigateToNode('altar'),
          new PlayAnimationNode('bow'),
          new PlaceOfferingNode(),
          new PlayAnimationNode('pray'),
          new WaitForResponseNode({timeout: 60000}),
          new ReactToResponseNode()
        ]);
        
      case 'rest':
        return new SequenceNode([
          new NavigateToNode('home'),
          new PlayAnimationNode('lie_down'),
          new SleepNode({duration: 'until_recovered'}),
          new PlayAnimationNode('wake_up')
        ]);
        
      default:
        return this.getDefaultBehaviorTree(action);
    }
  }
  
  /**
   * 执行行为树
   */
  private async executeBehaviorTree(
    tree: BehaviorTree,
    pet: Pet
  ): Promise<ExecutionResult> {
    const context = {
      pet,
      worldState: this.getWorldState(),
      blackboard: new Map()
    };
    
    const startTime = Date.now();
    let currentNode = tree.root;
    
    while (true) {
      const status = await currentNode.execute(context);
      
      if (status === NodeStatus.SUCCESS) {
        return {
          success: true,
          duration: Date.now() - startTime,
          outcome: context.blackboard.get('outcome')
        };
      }
      
      if (status === NodeStatus.FAILURE) {
        return {
          success: false,
          duration: Date.now() - startTime,
          failureReason: context.blackboard.get('failureReason')
        };
      }
      
      // RUNNING 状态，继续下一帧
      await this.waitNextFrame();
    }
  }
}
```

#### 2.2.4 表现层 (Presentation Layer)

**功能**：将AI的内部状态可视化展现给玩家

```csharp
/// <summary>
/// 表现系统 - AI的"表情"
/// </summary>
public partial class PresentationSystem : Node
{
  private AnimationPlayer _animationPlayer;
  private DialogueGenerator _dialogueGenerator;
  private EmotionExpressor _emotionExpressor;
  
  /**
   * 更新表现
   */
  public update(pet: Pet, decision: Decision): void {
    // 1. 更新动画状态
    this.updateAnimation(pet, decision);
    
    // 2. 更新情绪表情
    this.updateEmotionDisplay(pet);
    
    // 3. 生成思考气泡（可选）
    if (this.shouldShowThinking(decision)) {
      this.showThinkingBubble(pet, decision);
    }
    
    // 4. 触发对话（在特定情况下）
    if (this.shouldSpeak(pet, decision)) {
      this.generateAndShowDialogue(pet, decision);
    }
  }
  
  /**
   * 显示思考气泡
   */
  private showThinkingBubble(pet: Pet, decision: Decision): void {
    const thought = this.generateThought(pet, decision);
    
    UI.showBubble(pet, {
      type: 'thought',
      content: thought,
      duration: 3000,
      icon: this.getThoughtIcon(decision.action.type)
    });
  }
  
  /**
   * 生成思考内容
   */
  private generateThought(pet: Pet, decision: Decision): string {
    const templates = {
      hungry: [
        "好饿啊...",
        "该吃点东西了",
        "肚子咕咕叫"
      ],
      tired: [
        "好累...",
        "想休息一会",
        "需要睡个觉"
      ],
      happy: [
        "心情真好！",
        "今天真开心",
        "感觉棒极了"
      ],
      offering: [
        "该去供奉了",
        "准备去祭坛",
        "希望主人会喜欢"
      ],
      fishing: [
        "去钓鱼吧",
        "今天运气会好吗？",
        "池塘那边有大鱼"
      ]
    };
    
    const category = this.categorizeDecision(decision);
    const options = templates[category] || ["嗯..."];
    
    return options[Math.floor(Math.random() * options.length)];
  }
  
  /**
   * 生成对话
   */
  private generateAndShowDialogue(pet: Pet, decision: Decision): void {
    const dialogue = this.dialogueGenerator.generate({
      pet,
      decision,
      context: 'action_start',
      style: pet.personality.communicationStyle
    });
    
    UI.showDialogue(pet, dialogue);
  }
}
```

### 2.3 系统间接口设计

```typescript
/**
 * AI系统对外接口
 */
interface AISystemInterface {
  // 初始化
  initialize(pet: Pet, worldState: WorldState): void;
  
  // 主更新循环
  update(deltaTime: number): void;
  
  // 获取当前决策
  getCurrentDecision(): Decision | null;
  
  // 获取感知数据（用于调试）
  getPerceptionData(): PerceptionData;
  
  // 强制执行特定行动（玩家干预）
  forceAction(action: Action): void;
  
  // 暂停/恢复AI
  pause(): void;
  resume(): void;
  
  // 

调试模式
  enableDebugMode(): void;
  disableDebugMode(): void;
}

/**
 * 与游戏系统的数据交换接口
 */
interface AIDataInterface {
  // 需求系统接口
  getNeedsData(): NeedsData;
  updateNeed(needType: string, delta: number): void;
  
  // 情感系统接口
  getEmotionData(): EmotionData;
  triggerEmotion(emotionType: string, intensity: number): void;
  
  // 记忆系统接口
  storeMemory(memory: Memory): void;
  queryMemories(context: MemoryContext): Memory[];
  
  // 关系系统接口
  getRelationship(targetId: string): Relationship;
  updateRelationship(targetId: string, changes: RelationshipChanges): void;
  
  // 世界状态接口
  getWorldState(): WorldState;
  getSceneState(sceneId: string): SceneState;
  
  // 物品系统接口
  getInventory(): Item[];
  addItem(item: Item): boolean;
  removeItem(itemId: string): boolean;
  
  // 技能系统接口
  getSkills(): SkillData;
  addSkillXP(skillType: string, amount: number): void;
}
```

---

## 三、核心算法实现

### 3.1 效用理论系统（Utility System）

**设计理念**：效用理论是本项目AI的核心决策算法，它通过计算每个可能行动的"效用值"来选择最优行动。

#### 3.1.1 效用计算公式

```csharp
/// <summary>
/// 效用系统实现
/// </summary>
public partial class UtilitySystem : Node
{
  /// <summary>
  /// 主效用计算函数
   * 
   * 效用值 = Σ(维度得分 × 维度权重)
   * 
   * 六大维度：
   * 1. 需求满足效用（35%）
   * 2. 情感匹配效用（20%）
   * 3. 性格契合效用（15%）
   * 4. 社交关系效用（15%）
   * 5. 目标推进效用（10%）
   * 6. 探索好奇效用（5%）
   */
  public float CalculateUtility(AIAction action, PerceptionData perception)
  {
    var scores = new Dictionary<string, float>
    {
      ["needs"] = CalculateNeedsUtility(action, perception),
      ["emotions"] = CalculateEmotionalUtility(action, perception),
      ["personality"] = CalculatePersonalityUtility(action, perception),
      ["social"] = CalculateSocialUtility(action, perception),
      ["goals"] = CalculateGoalUtility(action, perception),
      ["exploration"] = CalculateExplorationUtility(action, perception)
    };
    
    var weights = GetDynamicWeights(perception);
    
    float totalUtility =
      scores["needs"] * weights.Needs +
      scores["emotions"] * weights.Emotions +
      scores["personality"] * weights.Personality +
      scores["social"] * weights.Social +
      scores["goals"] * weights.Goals +
      scores["exploration"] * weights.Exploration;
    
    // 应用修正因子
    float modifiedUtility = ApplyModifiers(totalUtility, action, perception);
    
    return Mathf.Max(0, modifiedUtility);
  }
  
  /**
   * 需求满足效用
   * 
   * 核心思想：紧急的需求对满足该需求的行动赋予高效用
   */
  private calculateNeedsUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const needs = perception.internalState.urgentNeeds;
    
    for (const need of needs) {
      // 预测行动对需求的影响
      const predictedChange = action.predictNeedChange(need.type);
      
      if (predictedChange > 0) {
        // 需求越低，满足它的效用越高
        const urgencyMultiplier = this.calculateUrgencyMultiplier(need.value);
        utility += predictedChange * urgencyMultiplier;
      } else if (predictedChange < 0) {
        // 降低已经很低的需求会严重降低效用
        if (need.value < 30) {
          utility += predictedChange * 2; // 负值，所以是减分
        }
      }
    }
    
    return utility;
  }
  
  /**
   * 紧急度乘数计算
   * 
   * 使用分段函数：
   * - 0-20: 极度紧急 (×5.0)
   * - 21-40: 很紧急 (×3.0)
   * - 41-60: 紧急 (×2.0)
   * - 61-80: 正常 (×1.0)
   * - 81-100: 不紧急 (×0.5)
   */
  private calculateUrgencyMultiplier(needValue: number): number {
    if (needValue <= 20) return 5.0;
    if (needValue <= 40) return 3.0;
    if (needValue <= 60) return 2.0;
    if (needValue <= 80) return 1.0;
    return 0.5;
  }
  
  /**
   * 情感匹配效用
   * 
   * 核心思想：情绪状态影响对不同活动的偏好
   */
  private calculateEmotionalUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const emotions = perception.internalState.emotionalState;
    
    // 快乐度高 → 偏好娱乐和社交
    if (emotions.joy > 70) {
      if (action.tags.includes('fun')) utility += 20;
      if (action.tags.includes('social')) utility += 15;
    }
    
    // 悲伤度高 → 寻求安慰或独处
    if (emotions.sadness > 60) {
      if (action.tags.includes('comfort')) utility += 25;
      if (action.tags.includes('solitude')) utility += 15;
      if (action.tags.includes('social')) utility -= 10;
    }
    
    // 愤怒度高 → 需要发泄
    if (emotions.anger > 50) {
      if (action.tags.includes('physical')) utility += 20;
      if (action.tags.includes('competitive')) utility += 15;
      if (action.tags.includes('social')) utility -= 15;
    }
    
    // 恐惧度高 → 避免冒险
    if (emotions.fear > 50) {
      if (action.tags.includes('safe')) utility += 15;
      if (action.tags.includes('risky')) utility -= 30;
    }
    
    // 平静状态 → 偏好常规活动
    if (emotions.joy < 50 && emotions.sadness < 50 && 
        emotions.anger < 50 && emotions.fear < 50) {
      if (action.tags.includes('routine')) utility += 10;
    }
    
    return utility;
  }
  
  /**
   * 性格契合效用
   * 
   * 核心思想：性格特质影响长期行为偏好
   */
  private calculatePersonalityUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const pet = perception.pet;
    
    // 检查性格特质对行动的影响
    for (const trait of pet.traits) {
      const traitEffect = this.getTraitEffect(trait, action);
      utility += traitEffect;
    }
    
    // 五大人格维度影响
    const personality = pet.personality;
    
    // 外向性 (Extraversion)
    if (personality.extraversion > 60) {
      if (action.tags.includes('social')) utility += 15;
      if (action.tags.includes('solitude')) utility -= 10;
    } else if (personality.extraversion < 40) {
      if (action.tags.includes('solitude')) utility += 15;
      if (action.tags.includes('social')) utility -= 10;
    }
    
    // 开放性 (Openness)
    if (personality.openness > 60) {
      if (action.tags.includes('novel')) utility += 12;
      if (action.tags.includes('explore')) utility += 10;
    }
    
    // 尽责性 (Conscientiousness)
    if (personality.conscientiousness > 60) {
      if (action.tags.includes('productive')) utility += 12;
      if (action.tags.includes('lazy')) utility -= 15;
    }
    
    // 宜人性 (Agreeableness)
    if (personality.agreeableness > 60) {
      if (action.tags.includes('helping')) utility += 10;
      if (action.tags.includes('selfish')) utility -= 10;
    }
    
    // 神经质 (Neuroticism)
    if (personality.neuroticism > 60) {
      if (action.tags.includes('safe')) utility += 8;
      if (action.tags.includes('risky')) utility -= 15;
    }
    
    return utility;
  }
  
  /**
   * 特质对行动的影响
   */
  private getTraitEffect(trait: string, action: Action): number {
    const traitEffects = {
      // 工作狂：工作类活动+15
      'workaholic': action.tags.includes('work') ? 15 : 0,
      
      // 懒惰：工作类活动-10，休闲+5
      'lazy': action.tags.includes('work') ? -10 : 
              (action.tags.includes('leisure') ? 5 : 0),
      
      // 贪吃：进食活动+10
      'foodie': action.tags.includes('eat') ? 10 : 0,
      
      // 社交恐惧：社交活动-20
      'social_anxiety': action.tags.includes('social') ? -20 : 0,
      
      // 完美主义：高质量活动+8
      'perfectionist': action.quality === 'high' ? 8 : -5,
      
      // 冒险家：探索活动+12
      'adventurous': action.tags.includes('explore') ? 12 : 0,
      
      // 虔诚：供奉相关+15
      'devout': action.tags.includes('offering') ? 15 : 0
    };
    
    return traitEffects[trait] || 0;
  }
  
  /**
   * 社交关系效用
   */
  private calculateSocialUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    
    // 如果是社交类行动
    if (action.type === 'social_interaction') {
      const target = action.target;
      const relationship = perception.pet.relationships.get(target);
      
      if (relationship) {
        // 关系好感影响社交意愿
        const affinityBonus = (relationship.affection - 50) / 5;
        utility += affinityBonus;
        
        // 亲密度影响深度互动意愿
        if (action.isDeepInteraction && relationship.intimacy > 60) {
          utility += 15;
        }
      }
    }
    
    // 孤独时间影响社交意愿
    const timeSinceLastSocial = perception.social.timeSinceLastInteraction;
    if (timeSinceLastSocial > 3600000) { // 1小时
      if (action.tags.includes('social')) {
        utility += Math.min(timeSinceLastSocial / 360000, 20);
      }
    }
    
    // 虔诚度影响供奉意愿
    if (action.type === 'make_offering') {
      const devotion = perception.pet.needs.devotion;
      if (devotion < 50) {
        utility += (50 - devotion) / 2;
      }
    }
    
    return utility;
  }
  
  /**
   * 目标推进效用
   */
  private calculateGoalUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const activeGoals = perception.internalState.activeGoals;
    
    for (const goal of activeGoals) {
      if (action.contributesToGoal(goal)) {
        // 基础推进效用
        utility += 20;
        
        // 目标进度越高，完成欲望越强
        const progress = goal.getProgress();
        if (progress > 0.7) {
          utility += 15;
        }
        
        // 目标优先级影响
        utility += goal.priority * 10;
      }
    }
    
    return utility;
  }
  
  /**
   * 探索好奇效用
   */
  private calculateExplorationUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const pet = perception.pet;
    
    // 新事物吸引力
    if (action.isNovel) {
      const curiosityFactor = pet.personality.openness / 10;
      utility += 10 + curiosityFactor;
    }
    
    // 重复行动疲劳
    const recentSimilarActions = pet.recentActions.filter(
      a => a.type === action.type
    ).length;
    
    if (recentSimilarActions > 3) {
      utility -= recentSimilarActions * 3;
    }
    
    // 稀有事件吸引力
    if (action.isRareOpportunity) {
      utility += 15;
    }
    
    return utility;
  }
  
  /**
   * 动态权重调整
   * 
   * 根据当前情境调整各维度权重
   */
  private getDynamicWeights(perception: PerceptionData): UtilityWeights {
    const baseWeights = {
      needs: 0.35,
      emotions: 0.20,
      personality: 0.15,
      social: 0.15,
      goals: 0.10,
      exploration: 0.05
    };
    
    // 生命阶段调整
    const lifeStage = perception.pet.lifeStage;
    if (lifeStage === 'childhood') {
      return {
        ...baseWeights,
        needs: 0.45,      // 幼年更关注需求
        exploration: 0.15  // 好奇心更强
      };
    }
    
    if (lifeStage === 'adult') {
      return {
        ...baseWeights,
        goals: 0.20,      // 成年更关注目标
        needs: 0.25
      };
    }
    
    if (lifeStage === 'elder') {
      return {
        ...baseWeights,
        social: 0.25,     // 老年更重视社交
        exploration: 0.02
      };
    }
    
    // 危机状态调整
    const hasEmergency = perception.internalState.urgentNeeds.some(
      need => need.value < 30
    );
    
    if (hasEmergency) {
      return {
        needs: 0.70,      // 

危机时需求权重占主导
        emotions: 0.15,
        personality: 0.05,
        social: 0.05,
        goals: 0.03,
        exploration: 0.02
      };
    }
    
    return baseWeights;
  }
  
  /**
   * 应用修正因子
   */
  private applyModifiers(
    baseUtility: number,
    action: Action,
    perception: PerceptionData
  ): number {
    let modified = baseUtility;
    
    // 时间因素修正
    const timeModifier = this.getTimeModifier(action, perception.temporal);
    modified *= timeModifier;
    
    // 天气因素修正
    const weatherModifier = this.getWeatherModifier(action, perception.environment.weather);
    modified *= weatherModifier;
    
    // 记忆影响修正
    const memoryModifier = this.getMemoryModifier(action, perception.memories);
    modified += memoryModifier;
    
    return modified;
  }
}
```

### 3.2 GOAP目标导向行动规划

**应用场景**：当桌宠有明确目标时（如"成为工匠"、"探索所有场景"），使用GOAP算法规划行动序列。

```typescript
/**
 * GOAP规划系统
 */
class GOAPPlanner {
  /**
   * 为目标生成行动计划
   */
  public planForGoal(goal: Goal, currentState: WorldState): Plan | null {
    // 1. 定义目标状态
    const goalState = goal.getDesiredState();
    
    // 2. 使用A*算法搜索从当前状态到目标状态的路径
    const path = this.aStarSearch(currentState, goalState);
    
    if (!path) return null;
    
    // 3. 将状态路径转换为行动序列
    const actions = this.statePathToActions(path);
    
    return {
      goal,
      actions,
      estimatedCost: this.calculatePlanCost(actions),
      estimatedDuration: this.calculatePlanDuration(actions)
    };
  }
  
  /**
   * A*搜索算法
   */
  private aStarSearch(
    start: WorldState,
    goal: WorldState
  ): WorldState[] | null {
    const openSet = new PriorityQueue<Node>();
    const closedSet = new Set<string>();
    
    openSet.add({
      state: start,
      gScore: 0,
      fScore: this.heuristic(start, goal),
      parent: null
    });
    
    while (!openSet.isEmpty()) {
      const current = openSet.pop();
      
      // 到达目标
      if (this.satisfiesGoal(current.state, goal)) {
        return this.reconstructPath(current);
      }
      
      closedSet.add(current.state.hash());
      
      // 探索所有可能的下一步行动
      for (const action of this.getAvailableActions(current.state)) {
        const nextState = action.apply(current.state);
        const stateHash = nextState.hash();
        
        if (closedSet.has(stateHash)) continue;
        
        const tentativeGScore = current.gScore + action.cost;
        
        const neighbor = {
          state: nextState,
          gScore: tentativeGScore,
          fScore: tentativeGScore + this.heuristic(nextState, goal),
          parent: current,
          action: action
        };
        
        openSet.add(neighbor);
      }
    }
    
    return null; // 无法找到路径
  }
  
  /**
   * 启发式函数（估计距离目标的成本）
   */
  private heuristic(state: WorldState, goal: WorldState): number {
    let distance = 0;
    
    // 计算状态差异
    for (const [key, targetValue] of Object.entries(goal)) {
      const currentValue = state[key];
      distance += Math.abs(targetValue - currentValue);
    }
    
    return distance;
  }
}
```

### 3.3 行为树系统

**应用场景**：复杂行动的执行序列控制（如钓鱼、供奉仪式等）。

```typescript
/**
 * 行为树节点类型
 */
enum NodeStatus {
  SUCCESS = 'success',
  FAILURE = 'failure',
  RUNNING = 'running'
}

/**
 * 行为树基础节点
 */
abstract class BTNode {
  abstract execute(context: BTContext): NodeStatus;
  abstract reset(): void;
}

/**
 * 顺序节点（Sequence）
 * 按顺序执行子节点，全部成功才成功
 */
class SequenceNode extends BTNode {
  private children: BTNode[];
  private currentIndex: number = 0;
  
  constructor(children: BTNode[]) {
    super();
    this.children = children;
  }
  
  execute(context: BTContext): NodeStatus {
    while (this.currentIndex < this.children.length) {
      const child = this.children[this.currentIndex];
      const status = child.execute(context);
      
      if (status === NodeStatus.FAILURE) {
        this.reset();
        return NodeStatus.FAILURE;
      }
      
      if (status === NodeStatus.RUNNING) {
        return NodeStatus.RUNNING;
      }
      
      // SUCCESS，继续下一个
      this.currentIndex++;
    }
    
    this.reset();
    return NodeStatus.SUCCESS;
  }
  
  reset(): void {
    this.currentIndex = 0;
    this.children.forEach(child => child.reset());
  }
}

/**
 * 选择节点（Selector）
 * 尝试执行子节点，有一个成功即成功
 */
class SelectorNode extends BTNode {
  private children: BTNode[];
  private currentIndex: number = 0;
  
  constructor(children: BTNode[]) {
    super();
    this.children = children;
  }
  
  execute(context: BTContext): NodeStatus {
    while (this.currentIndex < this.children.length) {
      const child = this.children[this.currentIndex];
      const status = child.execute(context);
      
      if (status === NodeStatus.SUCCESS) {
        this.reset();
        return NodeStatus.SUCCESS;
      }
      
      if (status === NodeStatus.RUNNING) {
        return NodeStatus.RUNNING;
      }
      
      // FAILURE，尝试下一个
      this.currentIndex++;
    }
    
    this.reset();
    return NodeStatus.FAILURE;
  }
  
  reset(): void {
    this.currentIndex = 0;
    this.children.forEach(child => child.reset());
  }
}

/**
 * 并行节点（Parallel）
 * 同时执行所有子节点
 */
class ParallelNode extends BTNode {
  private children: BTNode[];
  private policy: 'all' | 'any'; // 'all'需要全部成功，'any'需要至少一个成功
  
  constructor(children: BTNode[], policy: 'all' | 'any' = 'all') {
    super();
    this.children = children;
    this.policy = policy;
  }
  
  execute(context: BTContext): NodeStatus {
    let successCount = 0;
    let failureCount = 0;
    let runningCount = 0;
    
    for (const child of this.children) {
      const status = child.execute(context);
      
      if (status === NodeStatus.SUCCESS) successCount++;
      else if (status === NodeStatus.FAILURE) failureCount++;
      else if (status === NodeStatus.RUNNING) runningCount++;
    }
    
    if (this.policy === 'all') {
      if (failureCount > 0) return NodeStatus.FAILURE;
      if (successCount === this.children.length) return NodeStatus.SUCCESS;
      return NodeStatus.RUNNING;
    } else { // 'any'
      if (successCount > 0) return NodeStatus.SUCCESS;
      if (failureCount === this.children.length) return NodeStatus.FAILURE;
      return NodeStatus.RUNNING;
    }
  }
  
  reset(): void {
    this.children.forEach(child => child.reset());
  }
}

/**
 * 具体行为节点示例：导航到目标位置
 */
class NavigateToNode extends BTNode {
  private target: Vector3;
  private threshold: number = 0.5;
  
  constructor(target: Vector3 | string, threshold?: number) {
    super();
    if (typeof target === 'string') {
      this.target = this.resolveLocationName(target);
    } else {
      this.target = target;
    }
    if (threshold) this.threshold = threshold;
  }
  
  execute(context: BTContext): NodeStatus {
    const pet = context.pet;
    const distance = Vector3.distance(pet.position, this.target);
    
    if (distance <= this.threshold) {
      return NodeStatus.SUCCESS;
    }
    
    // 继续移动
    pet.moveTowards(this.target, context.deltaTime);
    return NodeStatus.RUNNING;
  }
  
  reset(): void {
    // 无需重置
  }
  
  private resolveLocationName(name: string): Vector3 {
    const locations = {
      'home': new Vector3(10, 0, 10),
      'altar': new Vector3(50, 0, 30),
      'pond': new Vector3(30, 0, 50),
      'field': new Vector3(20, 0, 20)
    };
    return locations[name] || new Vector3(0, 0, 0);
  }
}

/**
 * 具体行为节点示例：钓鱼
 */
class FishingBehaviorTree extends BTNode {
  private tree: BTNode;
  
  constructor() {
    super();
    
    // 构建钓鱼行为树
    this.tree = new SequenceNode([
      // 1. 导航到池塘
      new NavigateToNode('pond'),
      
      // 2. 装备钓竿
      new EquipToolNode('fishing_rod'),
      
      // 3. 播放抛竿动画
      new PlayAnimationNode('cast_line'),
      
      // 4. 等待鱼上钩或超时
      new SelectorNode([
        // 尝试钓鱼
        new SequenceNode([
          new WaitForBiteNode({maxWait: 60000}),
          new CheckBiteNode(),
          new PlayAnimationNode('reel_in'),
          new CatchFishNode(),
          new PlayAnimationNode('celebrate')
        ]),
        // 失败则显示失望
        new PlayAnimationNode('disappointed')
      ]),
      
      // 5. 收起钓竿
      new UnequipToolNode()
    ]);
  }
  
  execute(context: BTContext): NodeStatus {
    return this.tree.execute(context);
  }
  
  reset(): void {
    this.tree.reset();
  }
}
```

---

## 四、场景化AI设计

### 4.1 日常生活AI

**场景**：桌宠的日常自主生活

```typescript
/**
 * 日常生活AI控制器
 */
class DailyLifeAI {
  /**
   * 日常决策流程
   */
  public makeDailyDecision(pet: Pet, worldState: WorldState): Action {
    // 1. 检查紧急需求
    const urgentNeed = this.checkUrgentNeeds(pet);
    if (urgentNeed) {
      return this.satisfyUrgentNeed(urgentNeed, pet);
    }
    
    // 2. 检查定时活动（如用餐时间、睡觉时间）
    const scheduledAction = this.checkSchedule(pet, worldState);
    if (scheduledAction) {
      return scheduledAction;
    }
    
    // 3. 根据情境选择活动
    return this.chooseContextualActivity(pet, worldState);
  }
  
  /**
   * 情境化活动选择
   */
  private chooseContextualActivity(pet: Pet, worldState: WorldState): Action {
    const time = worldState.timeOfDay;
    const weather = worldState.weather;
    const season = worldState.season;
    
    // 早晨(6:00-9:00): 倾向户外活动
    if (time === 'morning') {
      if (weather === 'sunny') {
        return this.chooseFrom([
          'water_crops',
          'tend_garden',
          'go_fishing'
        ]);
      }
    }
    
    // 中午(12:00-14:00): 午餐和休息
    if (time === 'noon') {
      if (pet.needs.hunger < 60) {
        return new Action('eat_lunch');
      }
      return new Action('take_nap');
    }
    
    // 下午(14:00-18:00): 工作时间
    if (time === 'afternoon') {
      return this.chooseProductiveActivity(pet);
    }
    
    // 傍晚(18:00-20:00): 社交或供奉
    if (time === 'evening') {
      if (pet.needs.devotion < 50) {
        return new Action('make_offering');
      }
      return new Action('relax');
    }
    
    // 夜晚(20:00-22:00): 准备睡觉
    if (time === 'night') {
      return new Action('prepare_for_bed');
    }
    
    // 深夜(22:00-6:00): 睡觉
    return new Action('sleep');
  }
}
```

### 4.2 任务执行AI

**场景**：执行玩家委托的现实任务

```typescript
/**
 * 任务执行AI
 */
class TaskExecutionAI {
  /**
   * 评估任务可行性
   */
  public assessTask(task: Task, pet: Pet): TaskAssessment {
    const assessment = {
      canAttempt: true,
      successProbability: 0,
      requiredPreparations: [],
      estimatedDuration: 0,
      risks: []
    };
    
    // 1. 检查等级要求
    if (pet.level < task.minimumLevel) {
      assessment.canAttempt = false;
      assessment.requiredPreparations.push(
        `需要达到${task.minimumLevel}级`
      );
    }
    
    // 2. 检查工具要求
    for (const requiredTool of task.requiredTools) {
      if (!pet.hasLearned(requiredTool)) {
        assessment.canAttempt = false;
        assessment.requiredPreparations.push(
          `需要学习${requiredTool}`
        );
      }
    }
    
    // 3. 计算成功率（使用任务系统的6因子模型）
    if (assessment.canAttempt) {
      assessment.successProbability = this.calculateSuccessRate(task, pet);
    }
    
    // 4. 评估风险
    assessment.risks = this.assessRisks(task, pet);
    
    // 5. 估算时长
    assessment.estimatedDuration = this.estimateDuration(task, pet);
    
    return assessment;
  }
  
  /**
   * 执行任务
   */
  public async executeTask(task: Task, pet: Pet): Promise<TaskResult> {
    // 1. 前往工作台
    await this.navigateTo('workbench');
    
    // 2. 准备工具
    await this.prepareTools(task.requiredTools);
    
    // 3. 执行任务逻辑
    const result = await this.performTask(task, pet);
    
    // 4. 记录经验
    if (result.success) 

{
      this.recordExperience(task, pet);
    }
    
    return result;
  }
  
  /**
   * 6因子成功率计算
   */
  private calculateSuccessRate(task: Task, pet: Pet): number {
    // 基础成功率
    let rate = task.baseSuccessRate;
    
    // 1. 等级修正
    const levelDiff = pet.level - task.minimumLevel;
    rate *= (1 + Math.min(levelDiff * 0.02, 0.5));
    
    // 2. 体力修正
    const fatigueModifier = pet.needs.fatigue / 100;
    rate *= (0.5 + fatigueModifier * 0.5);
    
    // 3. 技能修正
    const relevantSkill = pet.skills[task.skillType];
    if (relevantSkill) {
      rate *= (1 + relevantSkill.level * 0.03);
    }
    
    // 4. 工具修正
    const toolLevel = pet.getToolLevel(task.requiredTools[0]);
    rate *= (1 + toolLevel * 0.05);
    
    // 5. 特质修正
    for (const trait of pet.traits) {
      const modifier = this.getTraitModifier(trait, task);
      rate *= modifier;
    }
    
    // 6. 情绪修正
    if (pet.emotions.fear > 60) {
      rate *= 0.9; // 恐惧降低成功率
    }
    if (pet.emotions.joy > 70) {
      rate *= 1.05; // 快乐提升成功率
    }
    
    // 限制在5%-99%之间
    return Math.max(0.05, Math.min(rate, 0.99));
  }
}
```

### 4.3 供奉决策AI

**场景**：决定何时供奉、供奉什么

```typescript
/**
 * 供奉决策AI
 */
class OfferingDecisionAI {
  /**
   * 判断是否应该供奉
   */
  public shouldMakeOffering(pet: Pet): boolean {
    // 必然触发条件
    if (pet.needs.devotion < 50 && pet.inventory.length > 0) {
      return true;
    }
    
    // 达成重大成就后
    if (pet.hasUnofferedAchievement()) {
      return true;
    }
    
    // 节日当天
    if (this.isSpecialDay()) {
      return true;
    }
    
    // 可能触发条件
    if (pet.needs.devotion > 80 && pet.emotions.joy > 80) {
      return Math.random() < 0.3; // 30%概率主动供奉
    }
    
    // 仓库过满
    if (pet.inventory.length > pet.inventoryCapacity * 0.8) {
      return Math.random() < 0.2; // 20%概率供奉释放空间
    }
    
    return false;
  }
  
  /**
   * 选择供奉物品
   */
  public selectOfferingItem(pet: Pet): Item {
    const candidates = pet.inventory.filter(item => item.canBeOffered);
    
    // 评分系统
    const scores = candidates.map(item => ({
      item,
      score: this.calculateOfferingScore(item, pet)
    }));
    
    scores.sort((a, b) => b.score - a.score);
    
    // 从前3个中随机选择（增加多样性）
    const topCandidates = scores.slice(0, Math.min(3, scores.length));
    const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
    
    return selected.item;
  }
  
  /**
   * 供奉物品评分
   */
  private calculateOfferingScore(item: Item, pet: Pet): number {
    let score = 0;
    
    // 基础：神力点数价值
    score += item.divinePowerValue;
    
    // 数量因素（数量多的优先）
    const itemCount = pet.inventory.filter(i => i.type === item.type).length;
    score += itemCount * 2;
    
    // 品质因素（虔诚度>80时更愿意供奉高品质）
    if (pet.needs.devotion > 80) {
      score += item.quality * 5;
    }
    
    // 需求因素（自己不急需的优先）
    if (item.type === 'food' && pet.needs.hunger < 30) {
      score -= 50; // 饥饿时不愿供奉食物
    }
    
    // 情感因素（有特殊记忆的物品加分）
    if (pet.hasMemoryOf(item)) {
      score += 10;
    }
    
    return score;
  }
}
```

---

## 五、性能优化策略

### 5.1 异步决策

```typescript
/**
 * 异步AI管理器
 */
class AsyncAIManager {
  private decisionQueue: PriorityQueue<AITask>;
  private worker: Worker;
  
  constructor() {
    // 创建Web Worker用于AI计算
    this.worker = new Worker('ai-worker.js');
    this.decisionQueue = new PriorityQueue();
  }
  
  /**
   * 提交AI决策任务
   */
  public async requestDecision(pet: Pet, priority: number): Promise<Decision> {
    return new Promise((resolve) => {
      const task = {
        id: generateId(),
        pet: this.serializePet(pet),
        worldState: this.serializeWorldState(),
        priority,
        timestamp: Date.now()
      };
      
      this.worker.postMessage({
        type: 'calculate_decision',
        task
      });
      
      this.worker.addEventListener('message', (e) => {
        if (e.data.taskId === task.id) {
          resolve(e.data.decision);
        }
      });
    });
  }
  
  /**
   * 批量处理
   */
  public async processBatch(pets: Pet[]): Promise<Map<string, Decision>> {
    const results = new Map();
    
    // 并行处理多个桌宠的决策
    const promises = pets.map(pet => 
      this.requestDecision(pet, 1).then(decision => {
        results.set(pet.id, decision);
      })
    );
    
    await Promise.all(promises);
    return results;
  }
}
```

### 5.2 决策缓存

```typescript
/**
 * 决策缓存系统
 */
class DecisionCache {
  private cache: Map<string, CachedDecision>;
  private ttl: number = 5000; // 5秒缓存时间
  
  /**
   * 获取缓存的决策
   */
  public get(pet: Pet, context: Context): Decision | null {
    const key = this.generateKey(pet, context);
    const cached = this.cache.get(key);
    
    if (!cached) return null;
    
    // 检查是否过期
    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    // 检查上下文是否有重大变化
    if (this.hasSignificantChange(cached.context, context)) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.decision;
  }
  
  /**
   * 缓存决策
   */
  public set(pet: Pet, context: Context, decision: Decision): void {
    const key = this.generateKey(pet, context);
    this.cache.set(key, {
      decision,
      context,
      timestamp: Date.now()
    });
  }
  
  /**
   * 检查是否有重大变化
   */
  private hasSignificantChange(oldContext: Context, newContext: Context): boolean {
    // 任何需求变化>10点视为重大变化
    for (const needType of ['hunger', 'fatigue', 'health']) {
      const diff = Math.abs(
        newContext.needs[needType] - oldContext.needs[needType]
      );
      if (diff > 10) return true;
    }
    
    // 场景变化
    if (oldContext.location !== newContext.location) return true;
    
    // 时段变化
    if (oldContext.timeOfDay !== newContext.timeOfDay) return true;
    
    return false;
  }
}
```

### 5.3 LOD（细节层次）系统

```typescript
/**
 * AI细节层次管理
 */
class AILODSystem {
  /**
   * 根据距离和重要性调整AI更新频率
   */
  public getUpdateInterval(pet: Pet, camera: Camera): number {
    const distance = Vector3.distance(pet.position, camera.position);
    
    // 距离玩家很近：每帧更新
    if (distance < 10) {
      return 0; // 每帧
    }
    
    // 中等距离：每秒2次
    if (distance < 30) {
      return 500; // 500ms
    }
    
    // 远距离：每2秒1次
    if (distance < 100) {
      return 2000;
    }
    
    // 非常远：每5秒1次或完全暂停
    return 5000;
  }
  
  /**
   * 简化AI计算
   */
  public getSimplificationLevel(pet: Pet): 'full' | 'simplified' | 'minimal' {
    if (pet.isPlayerControlled) return 'full';
    if (pet.isInView) return 'simplified';
    return 'minimal';
  }
}
```

---

## 六、调试与可视化

### 6.1 AI调试工具

```typescript
/**
 * AI调试系统
 */
class AIDebugger {
  private enabled: boolean = false;
  private logs: AIDebugLog[] = [];
  
  /**
   * 启用调试模式
   */
  public enable(): void {
    this.enabled = true;
    this.showDebugUI();
  }
  
  /**
   * 记录决策过程
   */
  public logDecision(decision: Decision, reasoning: Reasoning): void {
    if (!this.enabled) return;
    
    const log = {
      timestamp: Date.now(),
      petId: decision.petId,
      action: decision.action,
      utility: decision.utility,
      reasoning: reasoning,
      alternatives: decision.alternatives
    };
    
    this.logs.push(log);
    this.updateDebugUI(log);
  }
  
  /**
   * 显示调试UI
   */
  private showDebugUI(): void {
    const debugPanel = document.createElement('div');
    debugPanel.id = 'ai-debug-panel';
    debugPanel.innerHTML = `
      <h3>AI调试面板</h3>
      <div id="current-decision"></div>
      <div id="utility-breakdown"></div>
      <div id="perception-data"></div>
      <div id="decision-history"></div>
    `;
    document.body.appendChild(debugPanel);
  }
  
  /**
   * 更新调试UI
   */
  private updateDebugUI(log: AIDebugLog): void {
    // 当前决策
    document.getElementById('current-decision').innerHTML = `
      <strong>当前行动:</strong> ${log.action.type}<br>
      <strong>效用值:</strong> ${log.utility.toFixed(2)}<br>
      <strong>理由:</strong> ${log.reasoning.summary}
    `;
    
    // 效用分解
    const breakdown = log.reasoning.breakdown;
    document.getElementById('utility-breakdown').innerHTML = `
      <h4>效用分解:</h4>
      <ul>
        <li>需求: ${breakdown.needs.toFixed(2)}</li>
        <li>情感: ${breakdown.emotions.toFixed(2)}</li>
        <li>性格: ${breakdown.personality.toFixed(2)}</li>
        <li>社交: ${breakdown.social.toFixed(2)}</li>
        <li>目标: ${breakdown.goals.toFixed(2)}</li>
        <li>探索: ${breakdown.exploration.toFixed(2)}</li>
      </ul>
    `;
  }
  
  /**
   * 导出决策日志
   */
  public exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }
}
```

### 6.2 行为可视化

```typescript
/**
 * AI行为可视化
 */
class AIVisualizer {
  /**
   * 绘制思考气泡
   */
  public drawThinkingBubble(pet: Pet, thought: string): void {
    const bubble = this.createBubble({
      content: thought,
      duration: 3000,
      style: 'thought'
    });
    
    this.attachToPet(bubble, pet);
  }
  
  /**
   * 可视化决策树
   */
  public visualizeDecisionTree(tree: BehaviorTree): void {
    const canvas = document.getElementById('behavior-tree-canvas');
    const ctx = canvas.getContext('2d');
    
    this.drawNode(ctx, tree.root, {x: canvas.width / 2, y: 50});
  }
  
  /**
   * 绘制效用热力图
   */
  public drawUtilityHeatmap(utilities: Map<Action, number>): void {
    const maxUtility = Math.max(...Array.from(utilities.values()));
    
    for (const [action, utility] of utilities.entries()) {
      const color = this.utilityToColor(utility / maxUtility);
      this.highlightAction(action, color);
    }
  }
  
  private utilityToColor(normalized: number): string {
    // 从蓝色(低)到红色(高)
    const hue = (1 - normalized) * 240;
    return `hsl(${hue}, 100%, 50%)`;
  }
}
```

---

## 七、测试验证

### 7.1 单元测试

```typescript
describe('UtilitySystem', () => {
  let utilitySystem: UtilitySystem;
  let mockPet: Pet;
  let mockPerception: PerceptionData;
  
  beforeEach(() => {
    utilitySystem = new UtilitySystem();
    mockPet = createMockPet({
      needs: {hunger: 30, fatigue: 50, happiness: 70},
      personality: {extraversion: 60, openness: 70}
    });
    mockPerception = createMockPerception(mockPet);
  });
  
  test('饥饿时进食行动应有高效用', () => {
    const eatAction = new Action('eat');
    const utility = utilitySystem.calculateUtility(eatAction, mockPerception);
    
    expect(utility).toBeGreaterThan(50);
  });
  
  test('需求满足时相同行动效用应降低', () => {
    mockPet.needs.hunger = 90;
    const eatAction = new Action('eat');
    const utility = utilitySystem.calculateUtility(eatAction, mockPerception);
    
    expect(utility).toBeLessThan(20);
  });
  
  test('性格外向的桌宠更偏好社交', () => {
    const socialAction = new Action('socialize');
    const utility = utilitySystem.calculateUtility(socialAction, mockPerception);
    
    expect(utility).toBeGreaterThan(30);
  });
});
```

### 7.2 集成测试

```typescript
describe('AI决策流程集成测试', () => 

{
  test('完整决策流程：饥饿桌宠应选择进食', async () => {
    const aiSystem = new AISystem();
    const pet = createTestPet({needs: {hunger: 25}});
    const worldState = createTestWorldState();
    
    // 初始化系统
    aiSystem.initialize(pet, worldState);
    
    // 执行一次更新
    await aiSystem.update(16); // 16ms = 1帧
    
    // 验证决策
    const decision = aiSystem.getCurrentDecision();
    expect(decision.action.type).toBe('eat');
  });
  
  test('GOAP规划：应生成合理的行动序列', () => {
    const planner = new GOAPPlanner();
    const goal = new Goal('become_skilled_fisher', {
      skillLevel: {fishing: 5}
    });
    const currentState = {
      skillLevel: {fishing: 1},
      hasTools: ['fishing_rod']
    };
    
    const plan = planner.planForGoal(goal, currentState);
    
    expect(plan).not.toBeNull();
    expect(plan.actions.length).toBeGreaterThan(0);
    expect(plan.actions[0].type).toBe('go_fishing');
  });
});
```

### 7.3 压力测试

```typescript
describe('AI性能测试', () => {
  test('100个桌宠同时决策应在100ms内完成', async () => {
    const aiManager = new AsyncAIManager();
    const pets = Array.from({length: 100}, () => createRandomPet());
    
    const startTime = performance.now();
    await aiManager.processBatch(pets);
    const duration = performance.now() - startTime;
    
    expect(duration).toBeLessThan(100);
  });
  
  test('缓存命中率应>80%', () => {
    const cache = new DecisionCache();
    const pet = createTestPet();
    const context = createTestContext();
    
    // 模拟100次相似情境的决策请求
    let hits = 0;
    for (let i = 0; i < 100; i++) {
      const cached = cache.get(pet, context);
      if (cached) hits++;
      else {
        const decision = makeDecision(pet, context);
        cache.set(pet, context, decision);
      }
    }
    
    expect(hits / 100).toBeGreaterThan(0.8);
  });
});
```

---

## 八、未来扩展方向

### 8.1 学习型AI

```typescript
/**
 * 机器学习增强（未来版本）
 */
class LearningAI {
  /**
   * 从玩家反馈学习
   * 
   * 当玩家使用神力干预时，记录情境和玩家期望的行动
   * 通过强化学习逐渐调整决策倾向
   */
  public learnFromFeedback(
    situation: Situation,
    playerExpectedAction: Action,
    aiChosenAction: Action
  ): void {
    // 如果玩家干预，说明AI决策不理想
    if (playerExpectedAction !== aiChosenAction) {
      // 调整该情境下的效用权重
      this.adjustWeights(situation, playerExpectedAction);
      
      // 存储为训练样本
      this.trainingData.push({
        input: situation,
        expectedOutput: playerExpectedAction
      });
    }
  }
  
  /**
   * 个性化学习
   * 
   * 每个桌宠都有独特的学习曲线
   */
  public personalizedLearning(pet: Pet): void {
    // 分析该桌宠的历史行为模式
    const patterns = this.analyzePatterns(pet.history);
    
    // 调整该桌宠的AI参数
    pet.aiProfile.updatePreferences(patterns);
  }
}
```

### 8.2 社交网络AI

```typescript
/**
 * 多桌宠社交系统（扩展版本）
 */
class SocialNetworkAI {
  /**
   * 群体行为模拟
   * 
   * 多个桌宠之间的互动和影响
   */
  public simulateGroupDynamics(pets: Pet[]): void {
    // 构建社交网络图
    const network = this.buildSocialNetwork(pets);
    
    // 传播情绪
    this.propagateEmotions(network);
    
    // 形成小团体
    this.formCliques(network);
    
    // 触发群体事件
    this.triggerGroupEvents(network);
  }
  
  /**
   * 情绪传染
   */
  private propagateEmotions(network: SocialNetwork): void {
    for (const pet of network.nodes) {
      // 获取朋友的平均情绪
      const friends = network.getConnections(pet);
      const avgEmotion = this.averageEmotion(friends);
      
      // 朋友情绪影响自己（程度取决于亲密度）
      pet.emotions.adjust(avgEmotion, 0.1);
    }
  }
}
```

### 8.3 动态叙事生成

```typescript
/**
 * 叙事AI（高级功能）
 */
class NarrativeAI {
  /**
   * 生成动态故事
   * 
   * 基于桌宠的经历生成独特的故事线
   */
  public generateStory(pet: Pet): Story {
    // 提取关键记忆
    const keyMemories = pet.memorySystem.getKeyMemories();
    
    // 识别故事弧
    const arc = this.identifyStoryArc(keyMemories);
    
    // 生成叙事
    return this.constructNarrative(arc, pet);
  }
  
  /**
   * 识别故事弧
   */
  private identifyStoryArc(memories: Memory[]): StoryArc {
    // 分析情感变化曲线
    const emotionCurve = this.analyzeEmotionCurve(memories);
    
    // 识别转折点
    const turningPoints = this.findTurningPoints(emotionCurve);
    
    // 构建故事结构
    return {
      beginning: memories.slice(0, turningPoints[0]),
      rising: memories.slice(turningPoints[0], turningPoints[1]),
      climax: memories[turningPoints[1]],
      falling: memories.slice(turningPoints[1], turningPoints[2]),
      resolution: memories.slice(turningPoints[2])
    };
  }
}
```

---

## 九、总结与最佳实践

### 9.1 核心设计原则

1. **可解释性优先**：玩家需要理解AI的行为动机
   - ✅ 使用效用理论而非黑盒神经网络
   - ✅ 提供思考气泡和对话解释
   - ✅ 调试模式显示决策推理

2. **性能与复杂度平衡**：
   - ✅ 异步决策避免阻塞主线程
   - ✅ 缓存机制减少重复计算
   - ✅ LOD系统根据重要性调整更新频率

3. **行为多样性**：
   - ✅ Softmax选择增加随机性
   - ✅ 探索奖励避免重复行为
   - ✅ 性格和特质产生差异化

4. **系统集成**：
   - ✅ 清晰的接口定义
   - ✅ 模块化设计便于扩展
   - ✅ 与游戏其他系统良好配合

### 9.2 实现优先级

**MVP v1.0**（必须）：
- ✅ 基础效用系统
- ✅ 需求驱动决策
- ✅ 简单行为树
- ✅ 日常生活AI

**MVP v1.5**（重要）：
- ✅ 性格特质影响
- ✅ 情感系统集成
- ✅ 社交关系决策
- ✅ 供奉决策AI

**MVP v2.0**（需要）：
- ✅ GOAP目标规划
- ✅ 任务执行AI
- ✅ 复杂行为树
- ✅ 记忆影响决策

**MVP v3.0+**（想要）：
- ⏳ 学习型AI
- ⏳ 社交网络AI
- ⏳ 叙事生成AI

### 9.3 关键技术指标

| 指标 | 目标值 | 重要性 |
|-----|-------|-------|
| 决策延迟 | <50ms | ⭐⭐⭐⭐⭐ |
| 行为多样性 | 连续重复<3次 | ⭐⭐⭐⭐ |
| 玩家满意度 | >80% | ⭐⭐⭐⭐⭐ |
| 缓存命中率 | >80% | ⭐⭐⭐ |
| CPU占用 | <5% | ⭐⭐⭐⭐ |
| 内存占用 | <100MB | ⭐⭐⭐ |

### 9.4 开发建议

1. **迭代开发**：先实现简单AI，确保基础功能正常，再逐步增加复杂度
2. **充分测试**：AI系统容易产生意外行为，需要大量测试和调整
3. **数值调优**：效用权重、阈值等需要反复调整才能达到理想效果
4. **可视化调试**：开发调试工具能极大提升开发效率
5. **性能监控**：持续监控AI性能，及时发现瓶颈

### 9.5 常见陷阱与解决方案

| 陷阱 | 问题 | 解决方案 |
|-----|------|---------|
| **决策震荡** | AI频繁切换行动 | 增加决策粘性，添加冷却时间 |
| **局部最优** | AI陷入重复模式 | 增加探索奖励，引入随机性 |
| **性能问题** | AI计算过慢 | 异步处理，缓存，LOD |
| **行为不合理** | AI做出奇怪决策 | 添加约束条件，调整权重 |
| **缺乏个性** | 所有桌宠行为相同 | 强化性格特质影响 |

---

## 附录A：关键算法伪代码

### A.1 主AI循环

```
function AI_Main_Loop(pet, worldState):
    // 1. 感知
    perception = PerceptionSystem.perceive(pet, worldState)
    
    // 2. 检查缓存
    cachedDecision = DecisionCache.get(pet, perception)
    if cachedDecision and isStillValid(cachedDecision):
        return cachedDecision
    
    // 3. 决策
    decision = DecisionSystem.makeDecision(perception)
    
    // 4. 缓存
    DecisionCache.set(pet, perception, decision)
    
    // 5. 执行
    ExecutionSystem.execute(decision, pet)
    
    // 6. 表现
    PresentationSystem.update(pet, decision)
    
    return decision
```

### A.2 效用计算简化版

```
function Calculate_Utility(action, perception):
    utility = 0
    
    // 需求效用
    for each need in perception.needs:
        if action.satisfies(need):
            urgency = (100 - need.value) / 100
            utility += action.needSatisfaction * urgency * 35
    
    // 性格效用
    for each trait in perception.traits:
        if action.matchesTrait(trait):
            utility += 15
    
    // 目标效用
    if action.contributesToGoal(perception.activeGoal):
        utility += 20
    
    return utility
```

---

## 附录B：参考资料

### B.1 推荐阅读

- **《Game AI Pro》系列** - 游戏AI开发实践
- **《Behavioral Mathematics for Game AI》** - 效用理论详解
- **《Programming Game AI by Example》** - 行为树和状态机
- **《AI Game Engine Programming》** - AI引擎架构

### B.2 相关论文

- *Utility-Based AI for Games* - Dave Mark
- *Goal-Oriented Action Planning* - Jeff Orkin 