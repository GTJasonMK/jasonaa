
# 52-AIå®ç°æ–¹æ¡ˆ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.1 (Godot + C#é€‚é…ç‰ˆ)
> **æœ€åæ›´æ–°**: 2025-11-01
> **æŠ€æœ¯æ ˆ**: Godot 4.x + C#
> **è´Ÿè´£äºº**: å¾…å®š
> **ä¼˜å…ˆçº§**: â­â­â­â­â­ (æ ¸å¿ƒæŠ€æœ¯)
> **å®ç°ç‰ˆæœ¬**: MVP v1.0+

---

## ğŸ“‹ ç›¸å…³æ–‡æ¡£

**å‰ç½®ä¾èµ–**:
- [11-æ¡Œå® AIä¸éœ€æ±‚ç³»ç»Ÿ](../10-æ ¸å¿ƒç³»ç»Ÿ/11-æ¡Œå® AIä¸éœ€æ±‚ç³»ç»Ÿ.md) - AIè®¾è®¡éœ€æ±‚
- [51-æ¶æ„è®¾è®¡](./51-æ¶æ„è®¾è®¡.md) - ç³»ç»Ÿæ¶æ„åŸºç¡€
- [50-æ•°æ®ç»“æ„è®¾è®¡](./50-æ•°æ®ç»“æ„è®¾è®¡.md) - æ•°æ®æ¨¡å‹

**ç›¸å…³æ–‡æ¡£**:
- [30-ä¸ªæ€§åŒ–ç³»ç»Ÿ](../30-æ‰©å±•ç³»ç»Ÿ/30-ä¸ªæ€§åŒ–ç³»ç»Ÿ.md) - æ€§æ ¼ç‰¹è´¨
- [31-æƒ…æ„Ÿä¸è®°å¿†ç³»ç»Ÿ](../30-æ‰©å±•ç³»ç»Ÿ/31-æƒ…æ„Ÿä¸è®°å¿†ç³»ç»Ÿ.md) - æƒ…æ„Ÿæ¨¡å‹
- [32-å…³ç³»ç³»ç»Ÿ](../30-æ‰©å±•ç³»ç»Ÿ/32-å…³ç³»ç³»ç»Ÿ.md) - ç¤¾äº¤å†³ç­–
- [15-ä»»åŠ¡ç³»ç»Ÿ](../10-æ ¸å¿ƒç³»ç»Ÿ/15-ä»»åŠ¡ç³»ç»Ÿ.md) - ä»»åŠ¡æ‰§è¡ŒAI
- [07-æœ¯è¯­è¡¨](../00-è§„åˆ’/07-æœ¯è¯­è¡¨ä¸æ¦‚å¿µå®šä¹‰.md) - æœ¯è¯­å®šä¹‰

---

## ä¸€ã€AIç³»ç»Ÿæ¦‚è¿°ä¸å®šä½

### 1.1 è®¾è®¡ç†å¿µ

ã€Šæˆ‘çš„Ctueã€‹çš„AIç³»ç»Ÿä¸æ˜¯ä¼ ç»Ÿæ¸¸æˆä¸­çš„"æ•ŒäººAI"æˆ–"æˆ˜æ–—AI"ï¼Œè€Œæ˜¯ä¸€ä¸ª**ç”Ÿå‘½æ¨¡æ‹ŸAI**ï¼Œæ ¸å¿ƒç›®æ ‡æ˜¯åˆ›é€ ä¸€ä¸ªï¼š

- **å¯ä¿¡çš„è™šæ‹Ÿç”Ÿå‘½**ï¼šæ¡Œå® çš„è¡Œä¸ºåº”è¯¥è®©ç©å®¶æ„Ÿè§‰"å®ƒçœŸçš„åœ¨æ€è€ƒ"
- **æœ‰æ¸©åº¦çš„é™ªä¼´è€…**ï¼šä¸æ˜¯å·¥å…·ï¼Œè€Œæ˜¯æœ‰æ€§æ ¼ã€æœ‰æƒ…æ„Ÿçš„ä¼™ä¼´
- **è‡ªä¸»çš„å†³ç­–è€…**ï¼šèƒ½åœ¨æ²¡æœ‰ç©å®¶å¹²é¢„çš„æƒ…å†µä¸‹ç‹¬ç«‹ç”Ÿæ´»
- **å¯ç†è§£çš„ä¸ªä½“**ï¼šç©å®¶èƒ½é€šè¿‡è§‚å¯Ÿç†è§£æ¡Œå® çš„è¡Œä¸ºåŠ¨æœº

### 1.2 AIåœ¨é¡¹ç›®ä¸­çš„è§’è‰²å®šä½

```yaml
AIç³»ç»ŸèŒè´£åˆ’åˆ†:
  æ ¸å¿ƒèŒè´£:
    - æ¡Œå® è‡ªä¸»å†³ç­–: é€‰æ‹©ä¸‹ä¸€æ­¥åšä»€ä¹ˆï¼ˆç§æ¤/é’“é±¼/ä¼‘æ¯/ä¾›å¥‰ç­‰ï¼‰
    - éœ€æ±‚ç®¡ç†: ç›‘æ§å¹¶å“åº”äº”å¤§éœ€æ±‚ï¼ˆé¥¥é¥¿/ç–²åŠ³/å¿«ä¹/å¥åº·/è™”è¯šï¼‰
    - æƒ…æ„Ÿè¡¨è¾¾: æ ¹æ®æƒ…ç»ªçŠ¶æ€é€‰æ‹©é€‚å½“çš„åŠ¨ç”»å’Œå¯¹è¯
    - ç¤¾äº¤äº’åŠ¨: ä¸ç©å®¶å’ŒNPCå»ºç«‹å’Œç»´æŠ¤å…³ç³»
    - ä»»åŠ¡æ‰§è¡Œ: æ™ºèƒ½åœ°æ‰§è¡Œç©å®¶å§”æ‰˜çš„ç°å®ä»»åŠ¡
  
  æ¬¡è¦èŒè´£:
    - å­¦ä¹ è§„åˆ’: å†³å®šå­¦ä¹ å“ªäº›å·¥å…·ä¹¦å’ŒæŠ€èƒ½
    - ä¾›å¥‰å†³ç­–: é€‰æ‹©åˆé€‚çš„ç‰©å“å’Œæ—¶æœºè¿›è¡Œä¾›å¥‰
    - èµ„æºç®¡ç†: å¹³è¡¡è‡ªç”¨ã€å‡ºå”®ã€ä¾›å¥‰ä¸‰ç§èµ„æºåˆ†é…
    - ç›®æ ‡è¿½æ±‚: è¿½æ±‚é•¿æœŸç›®æ ‡ï¼ˆå¦‚æˆä¸ºå·¥åŒ ã€æ¢ç´¢è€…ç­‰ï¼‰
  
  ä¸è´Ÿè´£çš„éƒ¨åˆ†:
    - ç©å®¶æ“ä½œ: ç©å®¶ä¿ç•™å®Œå…¨çš„ç¥åŠ›æ§åˆ¶æƒ
    - æˆ˜æ–—AI: æœ¬é¡¹ç›®æ— æˆ˜æ–—ç³»ç»Ÿ
    - ç¨‹åºç”Ÿæˆ: ä¸–ç•Œå†…å®¹ç”±è®¾è®¡å¸ˆé¢„è®¾ï¼ŒéAIç”Ÿæˆ
```

### 1.3 å…³é”®è®¾è®¡æŒ‘æˆ˜

**æŒ‘æˆ˜1ï¼šå¹³è¡¡è‡ªä¸»æ€§ä¸å¯æ§æ€§**
- é—®é¢˜ï¼šæ¡Œå® å¤ªè‡ªä¸»ä¼šè®©ç©å®¶å¤±å»æŒæ§æ„Ÿï¼Œå¤ªæœºæ¢°åˆå¤±å»ç”Ÿå‘½æ„Ÿ
- æ–¹æ¡ˆï¼šé€šè¿‡ç¥åŠ›ç³»ç»Ÿæä¾›"é—´æ¥å½±å“"æœºåˆ¶ï¼Œç©å®¶ä¸ç›´æ¥æ§åˆ¶ä½†èƒ½å¼•å¯¼

**æŒ‘æˆ˜2ï¼šä¿æŒè¡Œä¸ºçš„å¤šæ ·æ€§ä¸åˆç†æ€§**
- é—®é¢˜ï¼šé‡å¤çš„è¡Œä¸ºæ¨¡å¼ä¼šè®©AIæ˜¾å¾—å‘†æ¿
- æ–¹æ¡ˆï¼šå¤šå±‚å†³ç­–ç³»ç»Ÿ + éšæœºæ€§æ³¨å…¥ + è®°å¿†ç³»ç»Ÿé¿å…é‡å¤

**æŒ‘æˆ˜3ï¼šæ€§èƒ½ä¸å¤æ‚åº¦çš„æƒè¡¡**
- é—®é¢˜ï¼šå¤æ‚çš„AIè®¡ç®—å¯èƒ½å½±å“æ¸¸æˆæ€§èƒ½
- æ–¹æ¡ˆï¼šåˆ†å±‚æ¶æ„ + å¼‚æ­¥å†³ç­– + ç¼“å­˜æœºåˆ¶

**æŒ‘æˆ˜4ï¼šAIè¡Œä¸ºçš„å¯è§£é‡Šæ€§**
- é—®é¢˜ï¼šç©å®¶éœ€è¦ç†è§£"æ¡Œå® ä¸ºä»€ä¹ˆè¿™ä¹ˆåš"
- æ–¹æ¡ˆï¼šUIæ˜¾ç¤ºæ€è€ƒæ°”æ³¡ + å¯¹è¯ç³»ç»Ÿè§£é‡ŠåŠ¨æœº

---

## äºŒã€AIæ¶æ„è®¾è®¡

### 2.1 åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç°å±‚ (Presentation)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  åŠ¨ç”»æ§åˆ¶   â”‚  â”‚  å¯¹è¯ç”Ÿæˆ   â”‚  â”‚  UIåé¦ˆ     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ‰§è¡Œå±‚ (Execution)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  è¡Œä¸ºæ ‘     â”‚  â”‚  åŠ¨ä½œç³»ç»Ÿ   â”‚  â”‚  å¯»è·¯ç³»ç»Ÿ   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å†³ç­–å±‚ (Decision)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  æ•ˆç”¨ç³»ç»Ÿ   â”‚  â”‚  ç›®æ ‡ç®¡ç†   â”‚  â”‚  è®¡åˆ’ç³»ç»Ÿ   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ„ŸçŸ¥å±‚ (Perception)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  éœ€æ±‚ç›‘æ§   â”‚  â”‚  ç¯å¢ƒæ„ŸçŸ¥   â”‚  â”‚  è®°å¿†æŸ¥è¯¢   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å±‚ (Data)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  éœ€æ±‚å€¼  â”‚  â”‚  æƒ…ç»ªå€¼  â”‚  â”‚  è®°å¿†åº“  â”‚  â”‚  ä¸–ç•ŒçŠ¶æ€â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 å„å±‚èŒè´£è¯¦è§£

#### 2.2.1 æ„ŸçŸ¥å±‚ (Perception Layer)

**åŠŸèƒ½**ï¼šæ”¶é›†å’Œå¤„ç†æ¡Œå® å¯æ„ŸçŸ¥çš„ä¿¡æ¯

```csharp
using Godot;
using System.Collections.Generic;

/// <summary>
/// æ„ŸçŸ¥ç³»ç»Ÿ - AIçš„"æ„Ÿå®˜"
/// </summary>
public partial class PerceptionSystem : Node
{
  private Pet _pet;
  private WorldState _worldState;
  
  /// <summary>
  /// æ„ŸçŸ¥æ›´æ–°ï¼ˆæ¯å¸§æˆ–å®šæ—¶è°ƒç”¨ï¼‰
  /// </summary>
  public PerceptionData Update(double deltaTime)
  {
    return new PerceptionData
    {
      // å†…éƒ¨æ„ŸçŸ¥ï¼šè‡ªèº«çŠ¶æ€
      InternalState = PerceiveInternalState(),
      
      // ç¯å¢ƒæ„ŸçŸ¥ï¼šå‘¨å›´ä¸–ç•Œ
      Environment = PerceiveEnvironment(),
      
      // ç¤¾äº¤æ„ŸçŸ¥ï¼šä»–äººçŠ¶æ€
      Social = PerceiveSocialContext(),
      
      // æ—¶é—´æ„ŸçŸ¥ï¼šæ—¶é—´ç›¸å…³ä¿¡æ¯
      Temporal = PerceiveTime(),
      
      // è®°å¿†æ£€ç´¢ï¼šç›¸å…³å†å²
      Memories = RetrieveRelevantMemories()
    };
  }
  
  /// <summary>
  /// å†…éƒ¨çŠ¶æ€æ„ŸçŸ¥
  /// </summary>
  private InternalPerception PerceiveInternalState()
  {
    var needs = _pet.Needs;
    
    return new InternalPerception
    {
      // éœ€æ±‚ç´§æ€¥ç¨‹åº¦æ’åº
      UrgentNeeds = RankNeedsByUrgency(needs),
      
      // å½“å‰æƒ…ç»ªçŠ¶æ€
      EmotionalState = _pet.Emotions,
      
      // ä½“åŠ›çŠ¶æ€
      EnergyLevel = needs.Fatigue,
      
      // æŠ€èƒ½çŠ¶å†µ
      Skills = _pet.Skills,
      
      // ä»“åº“çŠ¶æ€
      Inventory = new InventoryPerception
      {
        Items = _pet.Inventory,
        SpaceUsed = _pet.Inventory.Count,
        SpaceTotal = _pet.InventoryCapacity
      },
      
      // æ´»è·ƒç›®æ ‡
      ActiveGoals = _pet.Goals.Where(g => g.IsActive).ToList()
    };
  }
  
  /**
   * ç¯å¢ƒæ„ŸçŸ¥
   */
  private perceiveEnvironment(): EnvironmentPerception {
    const currentScene = this.worldState.currentScene;
    
    return {
      // å½“å‰åœºæ™¯
      location: currentScene.type,
      
      // å¤©æ°”çŠ¶å†µ
      weather: this.worldState.weather,
      
      // æ—¶æ®µï¼ˆæ—©æ™¨/ä¸­åˆ/å¤œæ™šï¼‰
      timeOfDay: this.worldState.timeOfDay,
      
      // å¯äº¤äº’å¯¹è±¡
      interactables: currentScene.getInteractablesInRange(
        this.pet.position,
        this.pet.perceptionRadius
      ),
      
      // é™„è¿‘NPC
      nearbyNPCs: currentScene.getNPCsInRange(
        this.pet.position,
        this.pet.socialPerceptionRadius
      ),
      
      // åœºæ™¯ç‰¹æ®ŠçŠ¶æ€ï¼ˆå¦‚ä½œç‰©æˆç†Ÿã€é±¼ä¸Šé’©ç­‰ï¼‰
      sceneEvents: currentScene.getActiveEvents()
    };
  }
  
  /**
   * ç¤¾äº¤æ„ŸçŸ¥
   */
  private perceiveSocialContext(): SocialPerception {
    return {
      // ä¸ç©å®¶çš„å…³ç³»
      playerRelationship: this.pet.relationships.get('player'),
      
      // æœ€è¿‘ä¸€æ¬¡äº’åŠ¨æ—¶é—´
      timeSinceLastInteraction: 
        Date.now() - this.pet.lastInteractionTime,
      
      // å¾…å“åº”çš„ç¥ˆç¥·
      pendingPrayers: this.pet.pendingPrayers,
      
      // é™„è¿‘NPCçš„æƒ…ç»ª
      nearbyEmotions: this.perceiveNearbyEmotions()
    };
  }
  
  /**
   * æ—¶é—´æ„ŸçŸ¥
   */
  private perceiveTime(): TemporalPerception {
    return {
      // æ´»åŠ¨æ—¶é—´ï¼ˆæ¸¸æˆæ—¶é—´ï¼‰
      activityTime: this.worldState.activityTime,
      
      // ç”Ÿå‘½æ—¶é—´ï¼ˆçœŸå®æ—¶é—´ï¼‰
      lifeTime: this.worldState.lifeTime,
      
      // å¹´é¾„
      age: this.pet.age,
      
      // ç”Ÿå‘½é˜¶æ®µ
      lifeStage: this.pet.lifeStage,
      
      // å­£èŠ‚
      season: this.worldState.season,
      
      

// èŠ‚æ—¥çŠ¶æ€
      specialEvents: this.worldState.activeEvents
    };
  }
  
  /**
   * æ£€ç´¢ç›¸å…³è®°å¿†
   */
  private retrieveRelevantMemories(): Memory[] {
    const currentContext = {
      location: this.worldState.currentScene.type,
      timeOfDay: this.worldState.timeOfDay,
      recentActions: this.pet.recentActions
    };
    
    // æ£€ç´¢ä¸å½“å‰æƒ…å¢ƒç›¸å…³çš„è®°å¿†
    return this.pet.memorySystem.retrieve(currentContext, 5);
  }
  
  /**
   * éœ€æ±‚ç´§æ€¥åº¦æ’åº
   */
  private rankNeedsByUrgency(needs: Needs): Array<{type: string, urgency: number}> {
    const needTypes = ['hunger', 'fatigue', 'happiness', 'health', 'devotion'];
    
    return needTypes.map(type => ({
      type,
      value: needs[type],
      urgency: this.calculateUrgency(needs[type], type)
    }))
    .sort((a, b) => b.urgency - a.urgency);
  }
  
  /**
   * ç´§æ€¥åº¦è®¡ç®—å…¬å¼
   */
  private calculateUrgency(value: number, type: string): number {
    // ä½¿ç”¨åæ¯”ä¾‹å‡½æ•°ï¼Œå€¼è¶Šä½è¶Šç´§æ€¥
    const urgency = 100 / (value + 10);
    
    // ä¸åŒéœ€æ±‚æœ‰ä¸åŒçš„ç´§æ€¥åº¦æƒé‡
    const weights = {
      hunger: 1.2,    // é¥¥é¥¿æœ€ç´§æ€¥
      health: 1.1,    // å¥åº·æ¬¡ä¹‹
      fatigue: 1.0,
      happiness: 0.8,
      devotion: 0.6   // è™”è¯šåº¦ç›¸å¯¹ä¸ç´§æ€¥
    };
    
    return urgency * (weights[type] || 1.0);
  }
}
```

#### 2.2.2 å†³ç­–å±‚ (Decision Layer)

**åŠŸèƒ½**ï¼šåŸºäºæ„ŸçŸ¥ä¿¡æ¯åšå‡ºè¡ŒåŠ¨å†³ç­–

```csharp
/// <summary>
/// å†³ç­–ç³»ç»Ÿ - AIçš„"å¤§è„‘"
/// </summary>
public partial class DecisionSystem : Node
{
  private UtilitySystem _utilitySystem;
  private GoalManager _goalManager;
  private PlanningSystem _planningSystem;
  
  /// <summary>
  /// ä¸»å†³ç­–å‡½æ•°
  /// </summary>
  public Decision MakeDecision(PerceptionData perception)
  {
    // 1. ç´§æ€¥æƒ…å†µæ£€æµ‹ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
    var emergency = DetectEmergency(perception);
    if (emergency != null)
    {
      return MakeEmergencyDecision(emergency);
    }
    
    // 2. ç›®æ ‡é©±åŠ¨å†³ç­–
    if (perception.InternalState.ActiveGoals.Count > 0)
    {
      var goalBasedDecision = MakeGoalBasedDecision(perception);
      if (goalBasedDecision.Priority > 0.7f)
      {
        return goalBasedDecision;
      }
    }
    
    // 3. æ•ˆç”¨é©±åŠ¨å†³ç­–ï¼ˆæ—¥å¸¸è¡Œä¸ºï¼‰
    return MakeUtilityBasedDecision(perception);
  }
  
  /**
   * ç´§æ€¥æƒ…å†µæ£€æµ‹
   */
  private detectEmergency(perception: PerceptionData): Emergency | null {
    const needs = perception.internalState.urgentNeeds;
    
    // ä»»ä½•éœ€æ±‚ä½äº20ä¸ºç´§æ€¥æƒ…å†µ
    for (const need of needs) {
      if (need.value < 20) {
        return {
          type: 'critical_need',
          needType: need.type,
          severity: 1.0 - (need.value / 20)
        };
      }
    }
    
    // å¥åº·åº¦ä½äº30ä¸”æŒç»­ä¸‹é™
    if (perception.internalState.energyLevel < 30 && 
        this.isNeedDecreasing('health')) {
      return {
        type: 'health_crisis',
        severity: 0.8
      };
    }
    
    return null;
  }
  
  /**
   * ç´§æ€¥å†³ç­–
   */
  private makeEmergencyDecision(emergency: Emergency): Decision {
    switch (emergency.type) {
      case 'critical_need':
        // ç«‹å³å¯»æ‰¾æ»¡è¶³éœ€æ±‚çš„è¡ŒåŠ¨
        return this.findNeedSatisfyingAction(emergency.needType);
        
      case 'health_crisis':
        // ç«‹å³ä¼‘æ¯æˆ–å¯»æ±‚æ²»ç–—
        return {
          action: 'rest',
          priority: 1.0,
          reason: 'å¥åº·å±æœºï¼Œéœ€è¦ç«‹å³ä¼‘æ¯'
        };
        
      default:
        return this.getDefaultAction();
    }
  }
  
  /**
   * ç›®æ ‡é©±åŠ¨å†³ç­–
   */
  private makeGoalBasedDecision(perception: PerceptionData): Decision {
    const activeGoal = perception.internalState.activeGoals[0];
    
    // ä½¿ç”¨GOAPï¼ˆç›®æ ‡å¯¼å‘è¡ŒåŠ¨è®¡åˆ’ï¼‰ç®—æ³•
    const plan = this.planningSystem.planForGoal(
      activeGoal,
      perception
    );
    
    if (plan && plan.actions.length > 0) {
      return {
        action: plan.actions[0],
        priority: 0.8,
        reason: `ä¸ºäº†å®ç°ç›®æ ‡: ${activeGoal.name}`,
        plannedSequence: plan.actions
      };
    }
    
    return null;
  }
  
  /**
   * æ•ˆç”¨é©±åŠ¨å†³ç­–ï¼ˆæ ¸å¿ƒç®—æ³•ï¼‰
   */
  private makeUtilityBasedDecision(perception: PerceptionData): Decision {
    // è·å–æ‰€æœ‰å¯æ‰§è¡Œçš„è¡ŒåŠ¨
    const availableActions = this.getAvailableActions(perception);
    
    // è®¡ç®—æ¯ä¸ªè¡ŒåŠ¨çš„æ•ˆç”¨å€¼
    const actionScores = availableActions.map(action => ({
      action,
      utility: this.utilitySystem.calculateUtility(action, perception),
      reasoning: this.utilitySystem.getReasoningBreakdown(action, perception)
    }));
    
    // æ’åºå¹¶é€‰æ‹©
    actionScores.sort((a, b) => b.utility - a.utility);
    
    // æ·»åŠ éšæœºæ€§ï¼ˆsoftmaxé€‰æ‹©ï¼‰
    const selected = this.softmaxSelection(actionScores.slice(0, 3));
    
    return {
      action: selected.action,
      priority: selected.utility / 100, // å½’ä¸€åŒ–åˆ°0-1
      reason: this.generateReasoningText(selected.reasoning),
      alternatives: actionScores.slice(0, 3).map(s => s.action)
    };
  }
  
  /**
   * Softmaxé€‰æ‹©ï¼ˆå¢åŠ è¡Œä¸ºå¤šæ ·æ€§ï¼‰
   */
  private softmaxSelection(
    candidates: Array<{action: Action, utility: number}>
  ): {action: Action, utility: number} {
    const temperature = 15; // æ¸©åº¦å‚æ•°ï¼Œæ§åˆ¶éšæœºæ€§
    
    const expScores = candidates.map(c => ({
      action: c.action,
      utility: c.utility,
      prob: Math.exp(c.utility / temperature)
    }));
    
    const totalProb = expScores.reduce((sum, item) => sum + item.prob, 0);
    const rand = Math.random() * totalProb;
    
    let cumulative = 0;
    for (const item of expScores) {
      cumulative += item.prob;
      if (rand <= cumulative) {
        return {action: item.action, utility: item.utility};
      }
    }
    
    return {action: candidates[0].action, utility: candidates[0].utility};
  }
}
```

#### 2.2.3 æ‰§è¡Œå±‚ (Execution Layer)

**åŠŸèƒ½**ï¼šå°†å†³ç­–è½¬åŒ–ä¸ºå…·ä½“çš„è¡Œä¸ºåºåˆ—

```csharp
/// <summary>
/// æ‰§è¡Œç³»ç»Ÿ - AIçš„"èº«ä½“"
/// </summary>
public partial class ExecutionSystem : Node
{
  private BehaviorTree _behaviorTree;
  private ActionExecutor _actionExecutor;
  private PathfindingSystem _pathfinding;
  
  /**
   * æ‰§è¡Œå†³ç­–
   */
  public async executeDecision(decision: Decision, pet: Pet): Promise<ExecutionResult> {
    // 1. åˆ†è§£ä¸ºè¡Œä¸ºæ ‘
    const behaviorTree = this.buildBehaviorTree(decision);
    
    // 2. æ‰§è¡Œè¡Œä¸ºæ ‘
    const result = await this.executeBehaviorTree(behaviorTree, pet);
    
    // 3. è®°å½•æ‰§è¡Œç»“æœ
    this.recordExecution(decision, result, pet);
    
    return result;
  }
  
  /**
   * æ„å»ºè¡Œä¸ºæ ‘
   */
  private buildBehaviorTree(decision: Decision): BehaviorTree {
    const action = decision.action;
    
    // æ ¹æ®è¡ŒåŠ¨ç±»å‹æ„å»ºä¸åŒçš„è¡Œä¸ºæ ‘
    switch (action.type) {
      case 'harvest_crop':
        return new SequenceNode([
          new NavigateToNode(action.target),
          new PlayAnimationNode('bend_down'),
          new HarvestNode(action.target),
          new PlayAnimationNode('stand_up'),
          new AddToInventoryNode(action.harvestedItem)
        ]);
        
      case 'go_fishing':
        return new SequenceNode([
          new NavigateToNode(action.location),
          new EquipToolNode('fishing_rod'),
          new PlayAnimationNode('cast_line'),
          new WaitForBiteNode({timeout: 60000}),
          new SelectorNode([
            new SequenceNode([
              new CheckBiteNode(),
              new PlayAnimationNode('reel_in'),
              new CatchFishNode(),
              new AddToInventoryNode('fish')
            ]),
            new PlayAnimationNode('disappointed')
          ])
        ]);
        
      case 'make_offering':
        return new SequenceNode([
          new SelectOfferingItemNode(),
          new NavigateToNode('altar'),
          new PlayAnimationNode('bow'),
          new PlaceOfferingNode(),
          new PlayAnimationNode('pray'),
          new WaitForResponseNode({timeout: 60000}),
          new ReactToResponseNode()
        ]);
        
      case 'rest':
        return new SequenceNode([
          new NavigateToNode('home'),
          new PlayAnimationNode('lie_down'),
          new SleepNode({duration: 'until_recovered'}),
          new PlayAnimationNode('wake_up')
        ]);
        
      default:
        return this.getDefaultBehaviorTree(action);
    }
  }
  
  /**
   * æ‰§è¡Œè¡Œä¸ºæ ‘
   */
  private async executeBehaviorTree(
    tree: BehaviorTree,
    pet: Pet
  ): Promise<ExecutionResult> {
    const context = {
      pet,
      worldState: this.getWorldState(),
      blackboard: new Map()
    };
    
    const startTime = Date.now();
    let currentNode = tree.root;
    
    while (true) {
      const status = await currentNode.execute(context);
      
      if (status === NodeStatus.SUCCESS) {
        return {
          success: true,
          duration: Date.now() - startTime,
          outcome: context.blackboard.get('outcome')
        };
      }
      
      if (status === NodeStatus.FAILURE) {
        return {
          success: false,
          duration: Date.now() - startTime,
          failureReason: context.blackboard.get('failureReason')
        };
      }
      
      // RUNNING çŠ¶æ€ï¼Œç»§ç»­ä¸‹ä¸€å¸§
      await this.waitNextFrame();
    }
  }
}
```

#### 2.2.4 è¡¨ç°å±‚ (Presentation Layer)

**åŠŸèƒ½**ï¼šå°†AIçš„å†…éƒ¨çŠ¶æ€å¯è§†åŒ–å±•ç°ç»™ç©å®¶

```csharp
/// <summary>
/// è¡¨ç°ç³»ç»Ÿ - AIçš„"è¡¨æƒ…"
/// </summary>
public partial class PresentationSystem : Node
{
  private AnimationPlayer _animationPlayer;
  private DialogueGenerator _dialogueGenerator;
  private EmotionExpressor _emotionExpressor;
  
  /**
   * æ›´æ–°è¡¨ç°
   */
  public update(pet: Pet, decision: Decision): void {
    // 1. æ›´æ–°åŠ¨ç”»çŠ¶æ€
    this.updateAnimation(pet, decision);
    
    // 2. æ›´æ–°æƒ…ç»ªè¡¨æƒ…
    this.updateEmotionDisplay(pet);
    
    // 3. ç”Ÿæˆæ€è€ƒæ°”æ³¡ï¼ˆå¯é€‰ï¼‰
    if (this.shouldShowThinking(decision)) {
      this.showThinkingBubble(pet, decision);
    }
    
    // 4. è§¦å‘å¯¹è¯ï¼ˆåœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼‰
    if (this.shouldSpeak(pet, decision)) {
      this.generateAndShowDialogue(pet, decision);
    }
  }
  
  /**
   * æ˜¾ç¤ºæ€è€ƒæ°”æ³¡
   */
  private showThinkingBubble(pet: Pet, decision: Decision): void {
    const thought = this.generateThought(pet, decision);
    
    UI.showBubble(pet, {
      type: 'thought',
      content: thought,
      duration: 3000,
      icon: this.getThoughtIcon(decision.action.type)
    });
  }
  
  /**
   * ç”Ÿæˆæ€è€ƒå†…å®¹
   */
  private generateThought(pet: Pet, decision: Decision): string {
    const templates = {
      hungry: [
        "å¥½é¥¿å•Š...",
        "è¯¥åƒç‚¹ä¸œè¥¿äº†",
        "è‚šå­å’•å’•å«"
      ],
      tired: [
        "å¥½ç´¯...",
        "æƒ³ä¼‘æ¯ä¸€ä¼š",
        "éœ€è¦ç¡ä¸ªè§‰"
      ],
      happy: [
        "å¿ƒæƒ…çœŸå¥½ï¼",
        "ä»Šå¤©çœŸå¼€å¿ƒ",
        "æ„Ÿè§‰æ£’æäº†"
      ],
      offering: [
        "è¯¥å»ä¾›å¥‰äº†",
        "å‡†å¤‡å»ç¥­å›",
        "å¸Œæœ›ä¸»äººä¼šå–œæ¬¢"
      ],
      fishing: [
        "å»é’“é±¼å§",
        "ä»Šå¤©è¿æ°”ä¼šå¥½å—ï¼Ÿ",
        "æ± å¡˜é‚£è¾¹æœ‰å¤§é±¼"
      ]
    };
    
    const category = this.categorizeDecision(decision);
    const options = templates[category] || ["å—¯..."];
    
    return options[Math.floor(Math.random() * options.length)];
  }
  
  /**
   * ç”Ÿæˆå¯¹è¯
   */
  private generateAndShowDialogue(pet: Pet, decision: Decision): void {
    const dialogue = this.dialogueGenerator.generate({
      pet,
      decision,
      context: 'action_start',
      style: pet.personality.communicationStyle
    });
    
    UI.showDialogue(pet, dialogue);
  }
}
```

### 2.3 ç³»ç»Ÿé—´æ¥å£è®¾è®¡

```typescript
/**
 * AIç³»ç»Ÿå¯¹å¤–æ¥å£
 */
interface AISystemInterface {
  // åˆå§‹åŒ–
  initialize(pet: Pet, worldState: WorldState): void;
  
  // ä¸»æ›´æ–°å¾ªç¯
  update(deltaTime: number): void;
  
  // è·å–å½“å‰å†³ç­–
  getCurrentDecision(): Decision | null;
  
  // è·å–æ„ŸçŸ¥æ•°æ®ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  getPerceptionData(): PerceptionData;
  
  // å¼ºåˆ¶æ‰§è¡Œç‰¹å®šè¡ŒåŠ¨ï¼ˆç©å®¶å¹²é¢„ï¼‰
  forceAction(action: Action): void;
  
  // æš‚åœ/æ¢å¤AI
  pause(): void;
  resume(): void;
  
  // 

è°ƒè¯•æ¨¡å¼
  enableDebugMode(): void;
  disableDebugMode(): void;
}

/**
 * ä¸æ¸¸æˆç³»ç»Ÿçš„æ•°æ®äº¤æ¢æ¥å£
 */
interface AIDataInterface {
  // éœ€æ±‚ç³»ç»Ÿæ¥å£
  getNeedsData(): NeedsData;
  updateNeed(needType: string, delta: number): void;
  
  // æƒ…æ„Ÿç³»ç»Ÿæ¥å£
  getEmotionData(): EmotionData;
  triggerEmotion(emotionType: string, intensity: number): void;
  
  // è®°å¿†ç³»ç»Ÿæ¥å£
  storeMemory(memory: Memory): void;
  queryMemories(context: MemoryContext): Memory[];
  
  // å…³ç³»ç³»ç»Ÿæ¥å£
  getRelationship(targetId: string): Relationship;
  updateRelationship(targetId: string, changes: RelationshipChanges): void;
  
  // ä¸–ç•ŒçŠ¶æ€æ¥å£
  getWorldState(): WorldState;
  getSceneState(sceneId: string): SceneState;
  
  // ç‰©å“ç³»ç»Ÿæ¥å£
  getInventory(): Item[];
  addItem(item: Item): boolean;
  removeItem(itemId: string): boolean;
  
  // æŠ€èƒ½ç³»ç»Ÿæ¥å£
  getSkills(): SkillData;
  addSkillXP(skillType: string, amount: number): void;
}
```

---

## ä¸‰ã€æ ¸å¿ƒç®—æ³•å®ç°

### 3.1 æ•ˆç”¨ç†è®ºç³»ç»Ÿï¼ˆUtility Systemï¼‰

**è®¾è®¡ç†å¿µ**ï¼šæ•ˆç”¨ç†è®ºæ˜¯æœ¬é¡¹ç›®AIçš„æ ¸å¿ƒå†³ç­–ç®—æ³•ï¼Œå®ƒé€šè¿‡è®¡ç®—æ¯ä¸ªå¯èƒ½è¡ŒåŠ¨çš„"æ•ˆç”¨å€¼"æ¥é€‰æ‹©æœ€ä¼˜è¡ŒåŠ¨ã€‚

#### 3.1.1 æ•ˆç”¨è®¡ç®—å…¬å¼

```csharp
/// <summary>
/// æ•ˆç”¨ç³»ç»Ÿå®ç°
/// </summary>
public partial class UtilitySystem : Node
{
  /// <summary>
  /// ä¸»æ•ˆç”¨è®¡ç®—å‡½æ•°
   * 
   * æ•ˆç”¨å€¼ = Î£(ç»´åº¦å¾—åˆ† Ã— ç»´åº¦æƒé‡)
   * 
   * å…­å¤§ç»´åº¦ï¼š
   * 1. éœ€æ±‚æ»¡è¶³æ•ˆç”¨ï¼ˆ35%ï¼‰
   * 2. æƒ…æ„ŸåŒ¹é…æ•ˆç”¨ï¼ˆ20%ï¼‰
   * 3. æ€§æ ¼å¥‘åˆæ•ˆç”¨ï¼ˆ15%ï¼‰
   * 4. ç¤¾äº¤å…³ç³»æ•ˆç”¨ï¼ˆ15%ï¼‰
   * 5. ç›®æ ‡æ¨è¿›æ•ˆç”¨ï¼ˆ10%ï¼‰
   * 6. æ¢ç´¢å¥½å¥‡æ•ˆç”¨ï¼ˆ5%ï¼‰
   */
  public float CalculateUtility(AIAction action, PerceptionData perception)
  {
    var scores = new Dictionary<string, float>
    {
      ["needs"] = CalculateNeedsUtility(action, perception),
      ["emotions"] = CalculateEmotionalUtility(action, perception),
      ["personality"] = CalculatePersonalityUtility(action, perception),
      ["social"] = CalculateSocialUtility(action, perception),
      ["goals"] = CalculateGoalUtility(action, perception),
      ["exploration"] = CalculateExplorationUtility(action, perception)
    };
    
    var weights = GetDynamicWeights(perception);
    
    float totalUtility =
      scores["needs"] * weights.Needs +
      scores["emotions"] * weights.Emotions +
      scores["personality"] * weights.Personality +
      scores["social"] * weights.Social +
      scores["goals"] * weights.Goals +
      scores["exploration"] * weights.Exploration;
    
    // åº”ç”¨ä¿®æ­£å› å­
    float modifiedUtility = ApplyModifiers(totalUtility, action, perception);
    
    return Mathf.Max(0, modifiedUtility);
  }
  
  /**
   * éœ€æ±‚æ»¡è¶³æ•ˆç”¨
   * 
   * æ ¸å¿ƒæ€æƒ³ï¼šç´§æ€¥çš„éœ€æ±‚å¯¹æ»¡è¶³è¯¥éœ€æ±‚çš„è¡ŒåŠ¨èµ‹äºˆé«˜æ•ˆç”¨
   */
  private calculateNeedsUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const needs = perception.internalState.urgentNeeds;
    
    for (const need of needs) {
      // é¢„æµ‹è¡ŒåŠ¨å¯¹éœ€æ±‚çš„å½±å“
      const predictedChange = action.predictNeedChange(need.type);
      
      if (predictedChange > 0) {
        // éœ€æ±‚è¶Šä½ï¼Œæ»¡è¶³å®ƒçš„æ•ˆç”¨è¶Šé«˜
        const urgencyMultiplier = this.calculateUrgencyMultiplier(need.value);
        utility += predictedChange * urgencyMultiplier;
      } else if (predictedChange < 0) {
        // é™ä½å·²ç»å¾ˆä½çš„éœ€æ±‚ä¼šä¸¥é‡é™ä½æ•ˆç”¨
        if (need.value < 30) {
          utility += predictedChange * 2; // è´Ÿå€¼ï¼Œæ‰€ä»¥æ˜¯å‡åˆ†
        }
      }
    }
    
    return utility;
  }
  
  /**
   * ç´§æ€¥åº¦ä¹˜æ•°è®¡ç®—
   * 
   * ä½¿ç”¨åˆ†æ®µå‡½æ•°ï¼š
   * - 0-20: æåº¦ç´§æ€¥ (Ã—5.0)
   * - 21-40: å¾ˆç´§æ€¥ (Ã—3.0)
   * - 41-60: ç´§æ€¥ (Ã—2.0)
   * - 61-80: æ­£å¸¸ (Ã—1.0)
   * - 81-100: ä¸ç´§æ€¥ (Ã—0.5)
   */
  private calculateUrgencyMultiplier(needValue: number): number {
    if (needValue <= 20) return 5.0;
    if (needValue <= 40) return 3.0;
    if (needValue <= 60) return 2.0;
    if (needValue <= 80) return 1.0;
    return 0.5;
  }
  
  /**
   * æƒ…æ„ŸåŒ¹é…æ•ˆç”¨
   * 
   * æ ¸å¿ƒæ€æƒ³ï¼šæƒ…ç»ªçŠ¶æ€å½±å“å¯¹ä¸åŒæ´»åŠ¨çš„åå¥½
   */
  private calculateEmotionalUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const emotions = perception.internalState.emotionalState;
    
    // å¿«ä¹åº¦é«˜ â†’ åå¥½å¨±ä¹å’Œç¤¾äº¤
    if (emotions.joy > 70) {
      if (action.tags.includes('fun')) utility += 20;
      if (action.tags.includes('social')) utility += 15;
    }
    
    // æ‚²ä¼¤åº¦é«˜ â†’ å¯»æ±‚å®‰æ…°æˆ–ç‹¬å¤„
    if (emotions.sadness > 60) {
      if (action.tags.includes('comfort')) utility += 25;
      if (action.tags.includes('solitude')) utility += 15;
      if (action.tags.includes('social')) utility -= 10;
    }
    
    // æ„¤æ€’åº¦é«˜ â†’ éœ€è¦å‘æ³„
    if (emotions.anger > 50) {
      if (action.tags.includes('physical')) utility += 20;
      if (action.tags.includes('competitive')) utility += 15;
      if (action.tags.includes('social')) utility -= 15;
    }
    
    // ææƒ§åº¦é«˜ â†’ é¿å…å†’é™©
    if (emotions.fear > 50) {
      if (action.tags.includes('safe')) utility += 15;
      if (action.tags.includes('risky')) utility -= 30;
    }
    
    // å¹³é™çŠ¶æ€ â†’ åå¥½å¸¸è§„æ´»åŠ¨
    if (emotions.joy < 50 && emotions.sadness < 50 && 
        emotions.anger < 50 && emotions.fear < 50) {
      if (action.tags.includes('routine')) utility += 10;
    }
    
    return utility;
  }
  
  /**
   * æ€§æ ¼å¥‘åˆæ•ˆç”¨
   * 
   * æ ¸å¿ƒæ€æƒ³ï¼šæ€§æ ¼ç‰¹è´¨å½±å“é•¿æœŸè¡Œä¸ºåå¥½
   */
  private calculatePersonalityUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const pet = perception.pet;
    
    // æ£€æŸ¥æ€§æ ¼ç‰¹è´¨å¯¹è¡ŒåŠ¨çš„å½±å“
    for (const trait of pet.traits) {
      const traitEffect = this.getTraitEffect(trait, action);
      utility += traitEffect;
    }
    
    // äº”å¤§äººæ ¼ç»´åº¦å½±å“
    const personality = pet.personality;
    
    // å¤–å‘æ€§ (Extraversion)
    if (personality.extraversion > 60) {
      if (action.tags.includes('social')) utility += 15;
      if (action.tags.includes('solitude')) utility -= 10;
    } else if (personality.extraversion < 40) {
      if (action.tags.includes('solitude')) utility += 15;
      if (action.tags.includes('social')) utility -= 10;
    }
    
    // å¼€æ”¾æ€§ (Openness)
    if (personality.openness > 60) {
      if (action.tags.includes('novel')) utility += 12;
      if (action.tags.includes('explore')) utility += 10;
    }
    
    // å°½è´£æ€§ (Conscientiousness)
    if (personality.conscientiousness > 60) {
      if (action.tags.includes('productive')) utility += 12;
      if (action.tags.includes('lazy')) utility -= 15;
    }
    
    // å®œäººæ€§ (Agreeableness)
    if (personality.agreeableness > 60) {
      if (action.tags.includes('helping')) utility += 10;
      if (action.tags.includes('selfish')) utility -= 10;
    }
    
    // ç¥ç»è´¨ (Neuroticism)
    if (personality.neuroticism > 60) {
      if (action.tags.includes('safe')) utility += 8;
      if (action.tags.includes('risky')) utility -= 15;
    }
    
    return utility;
  }
  
  /**
   * ç‰¹è´¨å¯¹è¡ŒåŠ¨çš„å½±å“
   */
  private getTraitEffect(trait: string, action: Action): number {
    const traitEffects = {
      // å·¥ä½œç‹‚ï¼šå·¥ä½œç±»æ´»åŠ¨+15
      'workaholic': action.tags.includes('work') ? 15 : 0,
      
      // æ‡’æƒ°ï¼šå·¥ä½œç±»æ´»åŠ¨-10ï¼Œä¼‘é—²+5
      'lazy': action.tags.includes('work') ? -10 : 
              (action.tags.includes('leisure') ? 5 : 0),
      
      // è´ªåƒï¼šè¿›é£Ÿæ´»åŠ¨+10
      'foodie': action.tags.includes('eat') ? 10 : 0,
      
      // ç¤¾äº¤ææƒ§ï¼šç¤¾äº¤æ´»åŠ¨-20
      'social_anxiety': action.tags.includes('social') ? -20 : 0,
      
      // å®Œç¾ä¸»ä¹‰ï¼šé«˜è´¨é‡æ´»åŠ¨+8
      'perfectionist': action.quality === 'high' ? 8 : -5,
      
      // å†’é™©å®¶ï¼šæ¢ç´¢æ´»åŠ¨+12
      'adventurous': action.tags.includes('explore') ? 12 : 0,
      
      // è™”è¯šï¼šä¾›å¥‰ç›¸å…³+15
      'devout': action.tags.includes('offering') ? 15 : 0
    };
    
    return traitEffects[trait] || 0;
  }
  
  /**
   * ç¤¾äº¤å…³ç³»æ•ˆç”¨
   */
  private calculateSocialUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    
    // å¦‚æœæ˜¯ç¤¾äº¤ç±»è¡ŒåŠ¨
    if (action.type === 'social_interaction') {
      const target = action.target;
      const relationship = perception.pet.relationships.get(target);
      
      if (relationship) {
        // å…³ç³»å¥½æ„Ÿå½±å“ç¤¾äº¤æ„æ„¿
        const affinityBonus = (relationship.affection - 50) / 5;
        utility += affinityBonus;
        
        // äº²å¯†åº¦å½±å“æ·±åº¦äº’åŠ¨æ„æ„¿
        if (action.isDeepInteraction && relationship.intimacy > 60) {
          utility += 15;
        }
      }
    }
    
    // å­¤ç‹¬æ—¶é—´å½±å“ç¤¾äº¤æ„æ„¿
    const timeSinceLastSocial = perception.social.timeSinceLastInteraction;
    if (timeSinceLastSocial > 3600000) { // 1å°æ—¶
      if (action.tags.includes('social')) {
        utility += Math.min(timeSinceLastSocial / 360000, 20);
      }
    }
    
    // è™”è¯šåº¦å½±å“ä¾›å¥‰æ„æ„¿
    if (action.type === 'make_offering') {
      const devotion = perception.pet.needs.devotion;
      if (devotion < 50) {
        utility += (50 - devotion) / 2;
      }
    }
    
    return utility;
  }
  
  /**
   * ç›®æ ‡æ¨è¿›æ•ˆç”¨
   */
  private calculateGoalUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const activeGoals = perception.internalState.activeGoals;
    
    for (const goal of activeGoals) {
      if (action.contributesToGoal(goal)) {
        // åŸºç¡€æ¨è¿›æ•ˆç”¨
        utility += 20;
        
        // ç›®æ ‡è¿›åº¦è¶Šé«˜ï¼Œå®Œæˆæ¬²æœ›è¶Šå¼º
        const progress = goal.getProgress();
        if (progress > 0.7) {
          utility += 15;
        }
        
        // ç›®æ ‡ä¼˜å…ˆçº§å½±å“
        utility += goal.priority * 10;
      }
    }
    
    return utility;
  }
  
  /**
   * æ¢ç´¢å¥½å¥‡æ•ˆç”¨
   */
  private calculateExplorationUtility(
    action: Action,
    perception: PerceptionData
  ): number {
    let utility = 0;
    const pet = perception.pet;
    
    // æ–°äº‹ç‰©å¸å¼•åŠ›
    if (action.isNovel) {
      const curiosityFactor = pet.personality.openness / 10;
      utility += 10 + curiosityFactor;
    }
    
    // é‡å¤è¡ŒåŠ¨ç–²åŠ³
    const recentSimilarActions = pet.recentActions.filter(
      a => a.type === action.type
    ).length;
    
    if (recentSimilarActions > 3) {
      utility -= recentSimilarActions * 3;
    }
    
    // ç¨€æœ‰äº‹ä»¶å¸å¼•åŠ›
    if (action.isRareOpportunity) {
      utility += 15;
    }
    
    return utility;
  }
  
  /**
   * åŠ¨æ€æƒé‡è°ƒæ•´
   * 
   * æ ¹æ®å½“å‰æƒ…å¢ƒè°ƒæ•´å„ç»´åº¦æƒé‡
   */
  private getDynamicWeights(perception: PerceptionData): UtilityWeights {
    const baseWeights = {
      needs: 0.35,
      emotions: 0.20,
      personality: 0.15,
      social: 0.15,
      goals: 0.10,
      exploration: 0.05
    };
    
    // ç”Ÿå‘½é˜¶æ®µè°ƒæ•´
    const lifeStage = perception.pet.lifeStage;
    if (lifeStage === 'childhood') {
      return {
        ...baseWeights,
        needs: 0.45,      // å¹¼å¹´æ›´å…³æ³¨éœ€æ±‚
        exploration: 0.15  // å¥½å¥‡å¿ƒæ›´å¼º
      };
    }
    
    if (lifeStage === 'adult') {
      return {
        ...baseWeights,
        goals: 0.20,      // æˆå¹´æ›´å…³æ³¨ç›®æ ‡
        needs: 0.25
      };
    }
    
    if (lifeStage === 'elder') {
      return {
        ...baseWeights,
        social: 0.25,     // è€å¹´æ›´é‡è§†ç¤¾äº¤
        exploration: 0.02
      };
    }
    
    // å±æœºçŠ¶æ€è°ƒæ•´
    const hasEmergency = perception.internalState.urgentNeeds.some(
      need => need.value < 30
    );
    
    if (hasEmergency) {
      return {
        needs: 0.70,      // 

å±æœºæ—¶éœ€æ±‚æƒé‡å ä¸»å¯¼
        emotions: 0.15,
        personality: 0.05,
        social: 0.05,
        goals: 0.03,
        exploration: 0.02
      };
    }
    
    return baseWeights;
  }
  
  /**
   * åº”ç”¨ä¿®æ­£å› å­
   */
  private applyModifiers(
    baseUtility: number,
    action: Action,
    perception: PerceptionData
  ): number {
    let modified = baseUtility;
    
    // æ—¶é—´å› ç´ ä¿®æ­£
    const timeModifier = this.getTimeModifier(action, perception.temporal);
    modified *= timeModifier;
    
    // å¤©æ°”å› ç´ ä¿®æ­£
    const weatherModifier = this.getWeatherModifier(action, perception.environment.weather);
    modified *= weatherModifier;
    
    // è®°å¿†å½±å“ä¿®æ­£
    const memoryModifier = this.getMemoryModifier(action, perception.memories);
    modified += memoryModifier;
    
    return modified;
  }
}
```

### 3.2 GOAPç›®æ ‡å¯¼å‘è¡ŒåŠ¨è§„åˆ’

**åº”ç”¨åœºæ™¯**ï¼šå½“æ¡Œå® æœ‰æ˜ç¡®ç›®æ ‡æ—¶ï¼ˆå¦‚"æˆä¸ºå·¥åŒ "ã€"æ¢ç´¢æ‰€æœ‰åœºæ™¯"ï¼‰ï¼Œä½¿ç”¨GOAPç®—æ³•è§„åˆ’è¡ŒåŠ¨åºåˆ—ã€‚

```typescript
/**
 * GOAPè§„åˆ’ç³»ç»Ÿ
 */
class GOAPPlanner {
  /**
   * ä¸ºç›®æ ‡ç”Ÿæˆè¡ŒåŠ¨è®¡åˆ’
   */
  public planForGoal(goal: Goal, currentState: WorldState): Plan | null {
    // 1. å®šä¹‰ç›®æ ‡çŠ¶æ€
    const goalState = goal.getDesiredState();
    
    // 2. ä½¿ç”¨A*ç®—æ³•æœç´¢ä»å½“å‰çŠ¶æ€åˆ°ç›®æ ‡çŠ¶æ€çš„è·¯å¾„
    const path = this.aStarSearch(currentState, goalState);
    
    if (!path) return null;
    
    // 3. å°†çŠ¶æ€è·¯å¾„è½¬æ¢ä¸ºè¡ŒåŠ¨åºåˆ—
    const actions = this.statePathToActions(path);
    
    return {
      goal,
      actions,
      estimatedCost: this.calculatePlanCost(actions),
      estimatedDuration: this.calculatePlanDuration(actions)
    };
  }
  
  /**
   * A*æœç´¢ç®—æ³•
   */
  private aStarSearch(
    start: WorldState,
    goal: WorldState
  ): WorldState[] | null {
    const openSet = new PriorityQueue<Node>();
    const closedSet = new Set<string>();
    
    openSet.add({
      state: start,
      gScore: 0,
      fScore: this.heuristic(start, goal),
      parent: null
    });
    
    while (!openSet.isEmpty()) {
      const current = openSet.pop();
      
      // åˆ°è¾¾ç›®æ ‡
      if (this.satisfiesGoal(current.state, goal)) {
        return this.reconstructPath(current);
      }
      
      closedSet.add(current.state.hash());
      
      // æ¢ç´¢æ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨
      for (const action of this.getAvailableActions(current.state)) {
        const nextState = action.apply(current.state);
        const stateHash = nextState.hash();
        
        if (closedSet.has(stateHash)) continue;
        
        const tentativeGScore = current.gScore + action.cost;
        
        const neighbor = {
          state: nextState,
          gScore: tentativeGScore,
          fScore: tentativeGScore + this.heuristic(nextState, goal),
          parent: current,
          action: action
        };
        
        openSet.add(neighbor);
      }
    }
    
    return null; // æ— æ³•æ‰¾åˆ°è·¯å¾„
  }
  
  /**
   * å¯å‘å¼å‡½æ•°ï¼ˆä¼°è®¡è·ç¦»ç›®æ ‡çš„æˆæœ¬ï¼‰
   */
  private heuristic(state: WorldState, goal: WorldState): number {
    let distance = 0;
    
    // è®¡ç®—çŠ¶æ€å·®å¼‚
    for (const [key, targetValue] of Object.entries(goal)) {
      const currentValue = state[key];
      distance += Math.abs(targetValue - currentValue);
    }
    
    return distance;
  }
}
```

### 3.3 è¡Œä¸ºæ ‘ç³»ç»Ÿ

**åº”ç”¨åœºæ™¯**ï¼šå¤æ‚è¡ŒåŠ¨çš„æ‰§è¡Œåºåˆ—æ§åˆ¶ï¼ˆå¦‚é’“é±¼ã€ä¾›å¥‰ä»ªå¼ç­‰ï¼‰ã€‚

```typescript
/**
 * è¡Œä¸ºæ ‘èŠ‚ç‚¹ç±»å‹
 */
enum NodeStatus {
  SUCCESS = 'success',
  FAILURE = 'failure',
  RUNNING = 'running'
}

/**
 * è¡Œä¸ºæ ‘åŸºç¡€èŠ‚ç‚¹
 */
abstract class BTNode {
  abstract execute(context: BTContext): NodeStatus;
  abstract reset(): void;
}

/**
 * é¡ºåºèŠ‚ç‚¹ï¼ˆSequenceï¼‰
 * æŒ‰é¡ºåºæ‰§è¡Œå­èŠ‚ç‚¹ï¼Œå…¨éƒ¨æˆåŠŸæ‰æˆåŠŸ
 */
class SequenceNode extends BTNode {
  private children: BTNode[];
  private currentIndex: number = 0;
  
  constructor(children: BTNode[]) {
    super();
    this.children = children;
  }
  
  execute(context: BTContext): NodeStatus {
    while (this.currentIndex < this.children.length) {
      const child = this.children[this.currentIndex];
      const status = child.execute(context);
      
      if (status === NodeStatus.FAILURE) {
        this.reset();
        return NodeStatus.FAILURE;
      }
      
      if (status === NodeStatus.RUNNING) {
        return NodeStatus.RUNNING;
      }
      
      // SUCCESSï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
      this.currentIndex++;
    }
    
    this.reset();
    return NodeStatus.SUCCESS;
  }
  
  reset(): void {
    this.currentIndex = 0;
    this.children.forEach(child => child.reset());
  }
}

/**
 * é€‰æ‹©èŠ‚ç‚¹ï¼ˆSelectorï¼‰
 * å°è¯•æ‰§è¡Œå­èŠ‚ç‚¹ï¼Œæœ‰ä¸€ä¸ªæˆåŠŸå³æˆåŠŸ
 */
class SelectorNode extends BTNode {
  private children: BTNode[];
  private currentIndex: number = 0;
  
  constructor(children: BTNode[]) {
    super();
    this.children = children;
  }
  
  execute(context: BTContext): NodeStatus {
    while (this.currentIndex < this.children.length) {
      const child = this.children[this.currentIndex];
      const status = child.execute(context);
      
      if (status === NodeStatus.SUCCESS) {
        this.reset();
        return NodeStatus.SUCCESS;
      }
      
      if (status === NodeStatus.RUNNING) {
        return NodeStatus.RUNNING;
      }
      
      // FAILUREï¼Œå°è¯•ä¸‹ä¸€ä¸ª
      this.currentIndex++;
    }
    
    this.reset();
    return NodeStatus.FAILURE;
  }
  
  reset(): void {
    this.currentIndex = 0;
    this.children.forEach(child => child.reset());
  }
}

/**
 * å¹¶è¡ŒèŠ‚ç‚¹ï¼ˆParallelï¼‰
 * åŒæ—¶æ‰§è¡Œæ‰€æœ‰å­èŠ‚ç‚¹
 */
class ParallelNode extends BTNode {
  private children: BTNode[];
  private policy: 'all' | 'any'; // 'all'éœ€è¦å…¨éƒ¨æˆåŠŸï¼Œ'any'éœ€è¦è‡³å°‘ä¸€ä¸ªæˆåŠŸ
  
  constructor(children: BTNode[], policy: 'all' | 'any' = 'all') {
    super();
    this.children = children;
    this.policy = policy;
  }
  
  execute(context: BTContext): NodeStatus {
    let successCount = 0;
    let failureCount = 0;
    let runningCount = 0;
    
    for (const child of this.children) {
      const status = child.execute(context);
      
      if (status === NodeStatus.SUCCESS) successCount++;
      else if (status === NodeStatus.FAILURE) failureCount++;
      else if (status === NodeStatus.RUNNING) runningCount++;
    }
    
    if (this.policy === 'all') {
      if (failureCount > 0) return NodeStatus.FAILURE;
      if (successCount === this.children.length) return NodeStatus.SUCCESS;
      return NodeStatus.RUNNING;
    } else { // 'any'
      if (successCount > 0) return NodeStatus.SUCCESS;
      if (failureCount === this.children.length) return NodeStatus.FAILURE;
      return NodeStatus.RUNNING;
    }
  }
  
  reset(): void {
    this.children.forEach(child => child.reset());
  }
}

/**
 * å…·ä½“è¡Œä¸ºèŠ‚ç‚¹ç¤ºä¾‹ï¼šå¯¼èˆªåˆ°ç›®æ ‡ä½ç½®
 */
class NavigateToNode extends BTNode {
  private target: Vector3;
  private threshold: number = 0.5;
  
  constructor(target: Vector3 | string, threshold?: number) {
    super();
    if (typeof target === 'string') {
      this.target = this.resolveLocationName(target);
    } else {
      this.target = target;
    }
    if (threshold) this.threshold = threshold;
  }
  
  execute(context: BTContext): NodeStatus {
    const pet = context.pet;
    const distance = Vector3.distance(pet.position, this.target);
    
    if (distance <= this.threshold) {
      return NodeStatus.SUCCESS;
    }
    
    // ç»§ç»­ç§»åŠ¨
    pet.moveTowards(this.target, context.deltaTime);
    return NodeStatus.RUNNING;
  }
  
  reset(): void {
    // æ— éœ€é‡ç½®
  }
  
  private resolveLocationName(name: string): Vector3 {
    const locations = {
      'home': new Vector3(10, 0, 10),
      'altar': new Vector3(50, 0, 30),
      'pond': new Vector3(30, 0, 50),
      'field': new Vector3(20, 0, 20)
    };
    return locations[name] || new Vector3(0, 0, 0);
  }
}

/**
 * å…·ä½“è¡Œä¸ºèŠ‚ç‚¹ç¤ºä¾‹ï¼šé’“é±¼
 */
class FishingBehaviorTree extends BTNode {
  private tree: BTNode;
  
  constructor() {
    super();
    
    // æ„å»ºé’“é±¼è¡Œä¸ºæ ‘
    this.tree = new SequenceNode([
      // 1. å¯¼èˆªåˆ°æ± å¡˜
      new NavigateToNode('pond'),
      
      // 2. è£…å¤‡é’“ç«¿
      new EquipToolNode('fishing_rod'),
      
      // 3. æ’­æ”¾æŠ›ç«¿åŠ¨ç”»
      new PlayAnimationNode('cast_line'),
      
      // 4. ç­‰å¾…é±¼ä¸Šé’©æˆ–è¶…æ—¶
      new SelectorNode([
        // å°è¯•é’“é±¼
        new SequenceNode([
          new WaitForBiteNode({maxWait: 60000}),
          new CheckBiteNode(),
          new PlayAnimationNode('reel_in'),
          new CatchFishNode(),
          new PlayAnimationNode('celebrate')
        ]),
        // å¤±è´¥åˆ™æ˜¾ç¤ºå¤±æœ›
        new PlayAnimationNode('disappointed')
      ]),
      
      // 5. æ”¶èµ·é’“ç«¿
      new UnequipToolNode()
    ]);
  }
  
  execute(context: BTContext): NodeStatus {
    return this.tree.execute(context);
  }
  
  reset(): void {
    this.tree.reset();
  }
}
```

---

## å››ã€åœºæ™¯åŒ–AIè®¾è®¡

### 4.1 æ—¥å¸¸ç”Ÿæ´»AI

**åœºæ™¯**ï¼šæ¡Œå® çš„æ—¥å¸¸è‡ªä¸»ç”Ÿæ´»

```typescript
/**
 * æ—¥å¸¸ç”Ÿæ´»AIæ§åˆ¶å™¨
 */
class DailyLifeAI {
  /**
   * æ—¥å¸¸å†³ç­–æµç¨‹
   */
  public makeDailyDecision(pet: Pet, worldState: WorldState): Action {
    // 1. æ£€æŸ¥ç´§æ€¥éœ€æ±‚
    const urgentNeed = this.checkUrgentNeeds(pet);
    if (urgentNeed) {
      return this.satisfyUrgentNeed(urgentNeed, pet);
    }
    
    // 2. æ£€æŸ¥å®šæ—¶æ´»åŠ¨ï¼ˆå¦‚ç”¨é¤æ—¶é—´ã€ç¡è§‰æ—¶é—´ï¼‰
    const scheduledAction = this.checkSchedule(pet, worldState);
    if (scheduledAction) {
      return scheduledAction;
    }
    
    // 3. æ ¹æ®æƒ…å¢ƒé€‰æ‹©æ´»åŠ¨
    return this.chooseContextualActivity(pet, worldState);
  }
  
  /**
   * æƒ…å¢ƒåŒ–æ´»åŠ¨é€‰æ‹©
   */
  private chooseContextualActivity(pet: Pet, worldState: WorldState): Action {
    const time = worldState.timeOfDay;
    const weather = worldState.weather;
    const season = worldState.season;
    
    // æ—©æ™¨(6:00-9:00): å€¾å‘æˆ·å¤–æ´»åŠ¨
    if (time === 'morning') {
      if (weather === 'sunny') {
        return this.chooseFrom([
          'water_crops',
          'tend_garden',
          'go_fishing'
        ]);
      }
    }
    
    // ä¸­åˆ(12:00-14:00): åˆé¤å’Œä¼‘æ¯
    if (time === 'noon') {
      if (pet.needs.hunger < 60) {
        return new Action('eat_lunch');
      }
      return new Action('take_nap');
    }
    
    // ä¸‹åˆ(14:00-18:00): å·¥ä½œæ—¶é—´
    if (time === 'afternoon') {
      return this.chooseProductiveActivity(pet);
    }
    
    // å‚æ™š(18:00-20:00): ç¤¾äº¤æˆ–ä¾›å¥‰
    if (time === 'evening') {
      if (pet.needs.devotion < 50) {
        return new Action('make_offering');
      }
      return new Action('relax');
    }
    
    // å¤œæ™š(20:00-22:00): å‡†å¤‡ç¡è§‰
    if (time === 'night') {
      return new Action('prepare_for_bed');
    }
    
    // æ·±å¤œ(22:00-6:00): ç¡è§‰
    return new Action('sleep');
  }
}
```

### 4.2 ä»»åŠ¡æ‰§è¡ŒAI

**åœºæ™¯**ï¼šæ‰§è¡Œç©å®¶å§”æ‰˜çš„ç°å®ä»»åŠ¡

```typescript
/**
 * ä»»åŠ¡æ‰§è¡ŒAI
 */
class TaskExecutionAI {
  /**
   * è¯„ä¼°ä»»åŠ¡å¯è¡Œæ€§
   */
  public assessTask(task: Task, pet: Pet): TaskAssessment {
    const assessment = {
      canAttempt: true,
      successProbability: 0,
      requiredPreparations: [],
      estimatedDuration: 0,
      risks: []
    };
    
    // 1. æ£€æŸ¥ç­‰çº§è¦æ±‚
    if (pet.level < task.minimumLevel) {
      assessment.canAttempt = false;
      assessment.requiredPreparations.push(
        `éœ€è¦è¾¾åˆ°${task.minimumLevel}çº§`
      );
    }
    
    // 2. æ£€æŸ¥å·¥å…·è¦æ±‚
    for (const requiredTool of task.requiredTools) {
      if (!pet.hasLearned(requiredTool)) {
        assessment.canAttempt = false;
        assessment.requiredPreparations.push(
          `éœ€è¦å­¦ä¹ ${requiredTool}`
        );
      }
    }
    
    // 3. è®¡ç®—æˆåŠŸç‡ï¼ˆä½¿ç”¨ä»»åŠ¡ç³»ç»Ÿçš„6å› å­æ¨¡å‹ï¼‰
    if (assessment.canAttempt) {
      assessment.successProbability = this.calculateSuccessRate(task, pet);
    }
    
    // 4. è¯„ä¼°é£é™©
    assessment.risks = this.assessRisks(task, pet);
    
    // 5. ä¼°ç®—æ—¶é•¿
    assessment.estimatedDuration = this.estimateDuration(task, pet);
    
    return assessment;
  }
  
  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  public async executeTask(task: Task, pet: Pet): Promise<TaskResult> {
    // 1. å‰å¾€å·¥ä½œå°
    await this.navigateTo('workbench');
    
    // 2. å‡†å¤‡å·¥å…·
    await this.prepareTools(task.requiredTools);
    
    // 3. æ‰§è¡Œä»»åŠ¡é€»è¾‘
    const result = await this.performTask(task, pet);
    
    // 4. è®°å½•ç»éªŒ
    if (result.success) 

{
      this.recordExperience(task, pet);
    }
    
    return result;
  }
  
  /**
   * 6å› å­æˆåŠŸç‡è®¡ç®—
   */
  private calculateSuccessRate(task: Task, pet: Pet): number {
    // åŸºç¡€æˆåŠŸç‡
    let rate = task.baseSuccessRate;
    
    // 1. ç­‰çº§ä¿®æ­£
    const levelDiff = pet.level - task.minimumLevel;
    rate *= (1 + Math.min(levelDiff * 0.02, 0.5));
    
    // 2. ä½“åŠ›ä¿®æ­£
    const fatigueModifier = pet.needs.fatigue / 100;
    rate *= (0.5 + fatigueModifier * 0.5);
    
    // 3. æŠ€èƒ½ä¿®æ­£
    const relevantSkill = pet.skills[task.skillType];
    if (relevantSkill) {
      rate *= (1 + relevantSkill.level * 0.03);
    }
    
    // 4. å·¥å…·ä¿®æ­£
    const toolLevel = pet.getToolLevel(task.requiredTools[0]);
    rate *= (1 + toolLevel * 0.05);
    
    // 5. ç‰¹è´¨ä¿®æ­£
    for (const trait of pet.traits) {
      const modifier = this.getTraitModifier(trait, task);
      rate *= modifier;
    }
    
    // 6. æƒ…ç»ªä¿®æ­£
    if (pet.emotions.fear > 60) {
      rate *= 0.9; // ææƒ§é™ä½æˆåŠŸç‡
    }
    if (pet.emotions.joy > 70) {
      rate *= 1.05; // å¿«ä¹æå‡æˆåŠŸç‡
    }
    
    // é™åˆ¶åœ¨5%-99%ä¹‹é—´
    return Math.max(0.05, Math.min(rate, 0.99));
  }
}
```

### 4.3 ä¾›å¥‰å†³ç­–AI

**åœºæ™¯**ï¼šå†³å®šä½•æ—¶ä¾›å¥‰ã€ä¾›å¥‰ä»€ä¹ˆ

```typescript
/**
 * ä¾›å¥‰å†³ç­–AI
 */
class OfferingDecisionAI {
  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥ä¾›å¥‰
   */
  public shouldMakeOffering(pet: Pet): boolean {
    // å¿…ç„¶è§¦å‘æ¡ä»¶
    if (pet.needs.devotion < 50 && pet.inventory.length > 0) {
      return true;
    }
    
    // è¾¾æˆé‡å¤§æˆå°±å
    if (pet.hasUnofferedAchievement()) {
      return true;
    }
    
    // èŠ‚æ—¥å½“å¤©
    if (this.isSpecialDay()) {
      return true;
    }
    
    // å¯èƒ½è§¦å‘æ¡ä»¶
    if (pet.needs.devotion > 80 && pet.emotions.joy > 80) {
      return Math.random() < 0.3; // 30%æ¦‚ç‡ä¸»åŠ¨ä¾›å¥‰
    }
    
    // ä»“åº“è¿‡æ»¡
    if (pet.inventory.length > pet.inventoryCapacity * 0.8) {
      return Math.random() < 0.2; // 20%æ¦‚ç‡ä¾›å¥‰é‡Šæ”¾ç©ºé—´
    }
    
    return false;
  }
  
  /**
   * é€‰æ‹©ä¾›å¥‰ç‰©å“
   */
  public selectOfferingItem(pet: Pet): Item {
    const candidates = pet.inventory.filter(item => item.canBeOffered);
    
    // è¯„åˆ†ç³»ç»Ÿ
    const scores = candidates.map(item => ({
      item,
      score: this.calculateOfferingScore(item, pet)
    }));
    
    scores.sort((a, b) => b.score - a.score);
    
    // ä»å‰3ä¸ªä¸­éšæœºé€‰æ‹©ï¼ˆå¢åŠ å¤šæ ·æ€§ï¼‰
    const topCandidates = scores.slice(0, Math.min(3, scores.length));
    const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
    
    return selected.item;
  }
  
  /**
   * ä¾›å¥‰ç‰©å“è¯„åˆ†
   */
  private calculateOfferingScore(item: Item, pet: Pet): number {
    let score = 0;
    
    // åŸºç¡€ï¼šç¥åŠ›ç‚¹æ•°ä»·å€¼
    score += item.divinePowerValue;
    
    // æ•°é‡å› ç´ ï¼ˆæ•°é‡å¤šçš„ä¼˜å…ˆï¼‰
    const itemCount = pet.inventory.filter(i => i.type === item.type).length;
    score += itemCount * 2;
    
    // å“è´¨å› ç´ ï¼ˆè™”è¯šåº¦>80æ—¶æ›´æ„¿æ„ä¾›å¥‰é«˜å“è´¨ï¼‰
    if (pet.needs.devotion > 80) {
      score += item.quality * 5;
    }
    
    // éœ€æ±‚å› ç´ ï¼ˆè‡ªå·±ä¸æ€¥éœ€çš„ä¼˜å…ˆï¼‰
    if (item.type === 'food' && pet.needs.hunger < 30) {
      score -= 50; // é¥¥é¥¿æ—¶ä¸æ„¿ä¾›å¥‰é£Ÿç‰©
    }
    
    // æƒ…æ„Ÿå› ç´ ï¼ˆæœ‰ç‰¹æ®Šè®°å¿†çš„ç‰©å“åŠ åˆ†ï¼‰
    if (pet.hasMemoryOf(item)) {
      score += 10;
    }
    
    return score;
  }
}
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 5.1 å¼‚æ­¥å†³ç­–

```typescript
/**
 * å¼‚æ­¥AIç®¡ç†å™¨
 */
class AsyncAIManager {
  private decisionQueue: PriorityQueue<AITask>;
  private worker: Worker;
  
  constructor() {
    // åˆ›å»ºWeb Workerç”¨äºAIè®¡ç®—
    this.worker = new Worker('ai-worker.js');
    this.decisionQueue = new PriorityQueue();
  }
  
  /**
   * æäº¤AIå†³ç­–ä»»åŠ¡
   */
  public async requestDecision(pet: Pet, priority: number): Promise<Decision> {
    return new Promise((resolve) => {
      const task = {
        id: generateId(),
        pet: this.serializePet(pet),
        worldState: this.serializeWorldState(),
        priority,
        timestamp: Date.now()
      };
      
      this.worker.postMessage({
        type: 'calculate_decision',
        task
      });
      
      this.worker.addEventListener('message', (e) => {
        if (e.data.taskId === task.id) {
          resolve(e.data.decision);
        }
      });
    });
  }
  
  /**
   * æ‰¹é‡å¤„ç†
   */
  public async processBatch(pets: Pet[]): Promise<Map<string, Decision>> {
    const results = new Map();
    
    // å¹¶è¡Œå¤„ç†å¤šä¸ªæ¡Œå® çš„å†³ç­–
    const promises = pets.map(pet => 
      this.requestDecision(pet, 1).then(decision => {
        results.set(pet.id, decision);
      })
    );
    
    await Promise.all(promises);
    return results;
  }
}
```

### 5.2 å†³ç­–ç¼“å­˜

```typescript
/**
 * å†³ç­–ç¼“å­˜ç³»ç»Ÿ
 */
class DecisionCache {
  private cache: Map<string, CachedDecision>;
  private ttl: number = 5000; // 5ç§’ç¼“å­˜æ—¶é—´
  
  /**
   * è·å–ç¼“å­˜çš„å†³ç­–
   */
  public get(pet: Pet, context: Context): Decision | null {
    const key = this.generateKey(pet, context);
    const cached = this.cache.get(key);
    
    if (!cached) return null;
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    // æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦æœ‰é‡å¤§å˜åŒ–
    if (this.hasSignificantChange(cached.context, context)) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.decision;
  }
  
  /**
   * ç¼“å­˜å†³ç­–
   */
  public set(pet: Pet, context: Context, decision: Decision): void {
    const key = this.generateKey(pet, context);
    this.cache.set(key, {
      decision,
      context,
      timestamp: Date.now()
    });
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤§å˜åŒ–
   */
  private hasSignificantChange(oldContext: Context, newContext: Context): boolean {
    // ä»»ä½•éœ€æ±‚å˜åŒ–>10ç‚¹è§†ä¸ºé‡å¤§å˜åŒ–
    for (const needType of ['hunger', 'fatigue', 'health']) {
      const diff = Math.abs(
        newContext.needs[needType] - oldContext.needs[needType]
      );
      if (diff > 10) return true;
    }
    
    // åœºæ™¯å˜åŒ–
    if (oldContext.location !== newContext.location) return true;
    
    // æ—¶æ®µå˜åŒ–
    if (oldContext.timeOfDay !== newContext.timeOfDay) return true;
    
    return false;
  }
}
```

### 5.3 LODï¼ˆç»†èŠ‚å±‚æ¬¡ï¼‰ç³»ç»Ÿ

```typescript
/**
 * AIç»†èŠ‚å±‚æ¬¡ç®¡ç†
 */
class AILODSystem {
  /**
   * æ ¹æ®è·ç¦»å’Œé‡è¦æ€§è°ƒæ•´AIæ›´æ–°é¢‘ç‡
   */
  public getUpdateInterval(pet: Pet, camera: Camera): number {
    const distance = Vector3.distance(pet.position, camera.position);
    
    // è·ç¦»ç©å®¶å¾ˆè¿‘ï¼šæ¯å¸§æ›´æ–°
    if (distance < 10) {
      return 0; // æ¯å¸§
    }
    
    // ä¸­ç­‰è·ç¦»ï¼šæ¯ç§’2æ¬¡
    if (distance < 30) {
      return 500; // 500ms
    }
    
    // è¿œè·ç¦»ï¼šæ¯2ç§’1æ¬¡
    if (distance < 100) {
      return 2000;
    }
    
    // éå¸¸è¿œï¼šæ¯5ç§’1æ¬¡æˆ–å®Œå…¨æš‚åœ
    return 5000;
  }
  
  /**
   * ç®€åŒ–AIè®¡ç®—
   */
  public getSimplificationLevel(pet: Pet): 'full' | 'simplified' | 'minimal' {
    if (pet.isPlayerControlled) return 'full';
    if (pet.isInView) return 'simplified';
    return 'minimal';
  }
}
```

---

## å…­ã€è°ƒè¯•ä¸å¯è§†åŒ–

### 6.1 AIè°ƒè¯•å·¥å…·

```typescript
/**
 * AIè°ƒè¯•ç³»ç»Ÿ
 */
class AIDebugger {
  private enabled: boolean = false;
  private logs: AIDebugLog[] = [];
  
  /**
   * å¯ç”¨è°ƒè¯•æ¨¡å¼
   */
  public enable(): void {
    this.enabled = true;
    this.showDebugUI();
  }
  
  /**
   * è®°å½•å†³ç­–è¿‡ç¨‹
   */
  public logDecision(decision: Decision, reasoning: Reasoning): void {
    if (!this.enabled) return;
    
    const log = {
      timestamp: Date.now(),
      petId: decision.petId,
      action: decision.action,
      utility: decision.utility,
      reasoning: reasoning,
      alternatives: decision.alternatives
    };
    
    this.logs.push(log);
    this.updateDebugUI(log);
  }
  
  /**
   * æ˜¾ç¤ºè°ƒè¯•UI
   */
  private showDebugUI(): void {
    const debugPanel = document.createElement('div');
    debugPanel.id = 'ai-debug-panel';
    debugPanel.innerHTML = `
      <h3>AIè°ƒè¯•é¢æ¿</h3>
      <div id="current-decision"></div>
      <div id="utility-breakdown"></div>
      <div id="perception-data"></div>
      <div id="decision-history"></div>
    `;
    document.body.appendChild(debugPanel);
  }
  
  /**
   * æ›´æ–°è°ƒè¯•UI
   */
  private updateDebugUI(log: AIDebugLog): void {
    // å½“å‰å†³ç­–
    document.getElementById('current-decision').innerHTML = `
      <strong>å½“å‰è¡ŒåŠ¨:</strong> ${log.action.type}<br>
      <strong>æ•ˆç”¨å€¼:</strong> ${log.utility.toFixed(2)}<br>
      <strong>ç†ç”±:</strong> ${log.reasoning.summary}
    `;
    
    // æ•ˆç”¨åˆ†è§£
    const breakdown = log.reasoning.breakdown;
    document.getElementById('utility-breakdown').innerHTML = `
      <h4>æ•ˆç”¨åˆ†è§£:</h4>
      <ul>
        <li>éœ€æ±‚: ${breakdown.needs.toFixed(2)}</li>
        <li>æƒ…æ„Ÿ: ${breakdown.emotions.toFixed(2)}</li>
        <li>æ€§æ ¼: ${breakdown.personality.toFixed(2)}</li>
        <li>ç¤¾äº¤: ${breakdown.social.toFixed(2)}</li>
        <li>ç›®æ ‡: ${breakdown.goals.toFixed(2)}</li>
        <li>æ¢ç´¢: ${breakdown.exploration.toFixed(2)}</li>
      </ul>
    `;
  }
  
  /**
   * å¯¼å‡ºå†³ç­–æ—¥å¿—
   */
  public exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }
}
```

### 6.2 è¡Œä¸ºå¯è§†åŒ–

```typescript
/**
 * AIè¡Œä¸ºå¯è§†åŒ–
 */
class AIVisualizer {
  /**
   * ç»˜åˆ¶æ€è€ƒæ°”æ³¡
   */
  public drawThinkingBubble(pet: Pet, thought: string): void {
    const bubble = this.createBubble({
      content: thought,
      duration: 3000,
      style: 'thought'
    });
    
    this.attachToPet(bubble, pet);
  }
  
  /**
   * å¯è§†åŒ–å†³ç­–æ ‘
   */
  public visualizeDecisionTree(tree: BehaviorTree): void {
    const canvas = document.getElementById('behavior-tree-canvas');
    const ctx = canvas.getContext('2d');
    
    this.drawNode(ctx, tree.root, {x: canvas.width / 2, y: 50});
  }
  
  /**
   * ç»˜åˆ¶æ•ˆç”¨çƒ­åŠ›å›¾
   */
  public drawUtilityHeatmap(utilities: Map<Action, number>): void {
    const maxUtility = Math.max(...Array.from(utilities.values()));
    
    for (const [action, utility] of utilities.entries()) {
      const color = this.utilityToColor(utility / maxUtility);
      this.highlightAction(action, color);
    }
  }
  
  private utilityToColor(normalized: number): string {
    // ä»è“è‰²(ä½)åˆ°çº¢è‰²(é«˜)
    const hue = (1 - normalized) * 240;
    return `hsl(${hue}, 100%, 50%)`;
  }
}
```

---

## ä¸ƒã€æµ‹è¯•éªŒè¯

### 7.1 å•å…ƒæµ‹è¯•

```typescript
describe('UtilitySystem', () => {
  let utilitySystem: UtilitySystem;
  let mockPet: Pet;
  let mockPerception: PerceptionData;
  
  beforeEach(() => {
    utilitySystem = new UtilitySystem();
    mockPet = createMockPet({
      needs: {hunger: 30, fatigue: 50, happiness: 70},
      personality: {extraversion: 60, openness: 70}
    });
    mockPerception = createMockPerception(mockPet);
  });
  
  test('é¥¥é¥¿æ—¶è¿›é£Ÿè¡ŒåŠ¨åº”æœ‰é«˜æ•ˆç”¨', () => {
    const eatAction = new Action('eat');
    const utility = utilitySystem.calculateUtility(eatAction, mockPerception);
    
    expect(utility).toBeGreaterThan(50);
  });
  
  test('éœ€æ±‚æ»¡è¶³æ—¶ç›¸åŒè¡ŒåŠ¨æ•ˆç”¨åº”é™ä½', () => {
    mockPet.needs.hunger = 90;
    const eatAction = new Action('eat');
    const utility = utilitySystem.calculateUtility(eatAction, mockPerception);
    
    expect(utility).toBeLessThan(20);
  });
  
  test('æ€§æ ¼å¤–å‘çš„æ¡Œå® æ›´åå¥½ç¤¾äº¤', () => {
    const socialAction = new Action('socialize');
    const utility = utilitySystem.calculateUtility(socialAction, mockPerception);
    
    expect(utility).toBeGreaterThan(30);
  });
});
```

### 7.2 é›†æˆæµ‹è¯•

```typescript
describe('AIå†³ç­–æµç¨‹é›†æˆæµ‹è¯•', () => 

{
  test('å®Œæ•´å†³ç­–æµç¨‹ï¼šé¥¥é¥¿æ¡Œå® åº”é€‰æ‹©è¿›é£Ÿ', async () => {
    const aiSystem = new AISystem();
    const pet = createTestPet({needs: {hunger: 25}});
    const worldState = createTestWorldState();
    
    // åˆå§‹åŒ–ç³»ç»Ÿ
    aiSystem.initialize(pet, worldState);
    
    // æ‰§è¡Œä¸€æ¬¡æ›´æ–°
    await aiSystem.update(16); // 16ms = 1å¸§
    
    // éªŒè¯å†³ç­–
    const decision = aiSystem.getCurrentDecision();
    expect(decision.action.type).toBe('eat');
  });
  
  test('GOAPè§„åˆ’ï¼šåº”ç”Ÿæˆåˆç†çš„è¡ŒåŠ¨åºåˆ—', () => {
    const planner = new GOAPPlanner();
    const goal = new Goal('become_skilled_fisher', {
      skillLevel: {fishing: 5}
    });
    const currentState = {
      skillLevel: {fishing: 1},
      hasTools: ['fishing_rod']
    };
    
    const plan = planner.planForGoal(goal, currentState);
    
    expect(plan).not.toBeNull();
    expect(plan.actions.length).toBeGreaterThan(0);
    expect(plan.actions[0].type).toBe('go_fishing');
  });
});
```

### 7.3 å‹åŠ›æµ‹è¯•

```typescript
describe('AIæ€§èƒ½æµ‹è¯•', () => {
  test('100ä¸ªæ¡Œå® åŒæ—¶å†³ç­–åº”åœ¨100mså†…å®Œæˆ', async () => {
    const aiManager = new AsyncAIManager();
    const pets = Array.from({length: 100}, () => createRandomPet());
    
    const startTime = performance.now();
    await aiManager.processBatch(pets);
    const duration = performance.now() - startTime;
    
    expect(duration).toBeLessThan(100);
  });
  
  test('ç¼“å­˜å‘½ä¸­ç‡åº”>80%', () => {
    const cache = new DecisionCache();
    const pet = createTestPet();
    const context = createTestContext();
    
    // æ¨¡æ‹Ÿ100æ¬¡ç›¸ä¼¼æƒ…å¢ƒçš„å†³ç­–è¯·æ±‚
    let hits = 0;
    for (let i = 0; i < 100; i++) {
      const cached = cache.get(pet, context);
      if (cached) hits++;
      else {
        const decision = makeDecision(pet, context);
        cache.set(pet, context, decision);
      }
    }
    
    expect(hits / 100).toBeGreaterThan(0.8);
  });
});
```

---

## å…«ã€æœªæ¥æ‰©å±•æ–¹å‘

### 8.1 å­¦ä¹ å‹AI

```typescript
/**
 * æœºå™¨å­¦ä¹ å¢å¼ºï¼ˆæœªæ¥ç‰ˆæœ¬ï¼‰
 */
class LearningAI {
  /**
   * ä»ç©å®¶åé¦ˆå­¦ä¹ 
   * 
   * å½“ç©å®¶ä½¿ç”¨ç¥åŠ›å¹²é¢„æ—¶ï¼Œè®°å½•æƒ…å¢ƒå’Œç©å®¶æœŸæœ›çš„è¡ŒåŠ¨
   * é€šè¿‡å¼ºåŒ–å­¦ä¹ é€æ¸è°ƒæ•´å†³ç­–å€¾å‘
   */
  public learnFromFeedback(
    situation: Situation,
    playerExpectedAction: Action,
    aiChosenAction: Action
  ): void {
    // å¦‚æœç©å®¶å¹²é¢„ï¼Œè¯´æ˜AIå†³ç­–ä¸ç†æƒ³
    if (playerExpectedAction !== aiChosenAction) {
      // è°ƒæ•´è¯¥æƒ…å¢ƒä¸‹çš„æ•ˆç”¨æƒé‡
      this.adjustWeights(situation, playerExpectedAction);
      
      // å­˜å‚¨ä¸ºè®­ç»ƒæ ·æœ¬
      this.trainingData.push({
        input: situation,
        expectedOutput: playerExpectedAction
      });
    }
  }
  
  /**
   * ä¸ªæ€§åŒ–å­¦ä¹ 
   * 
   * æ¯ä¸ªæ¡Œå® éƒ½æœ‰ç‹¬ç‰¹çš„å­¦ä¹ æ›²çº¿
   */
  public personalizedLearning(pet: Pet): void {
    // åˆ†æè¯¥æ¡Œå® çš„å†å²è¡Œä¸ºæ¨¡å¼
    const patterns = this.analyzePatterns(pet.history);
    
    // è°ƒæ•´è¯¥æ¡Œå® çš„AIå‚æ•°
    pet.aiProfile.updatePreferences(patterns);
  }
}
```

### 8.2 ç¤¾äº¤ç½‘ç»œAI

```typescript
/**
 * å¤šæ¡Œå® ç¤¾äº¤ç³»ç»Ÿï¼ˆæ‰©å±•ç‰ˆæœ¬ï¼‰
 */
class SocialNetworkAI {
  /**
   * ç¾¤ä½“è¡Œä¸ºæ¨¡æ‹Ÿ
   * 
   * å¤šä¸ªæ¡Œå® ä¹‹é—´çš„äº’åŠ¨å’Œå½±å“
   */
  public simulateGroupDynamics(pets: Pet[]): void {
    // æ„å»ºç¤¾äº¤ç½‘ç»œå›¾
    const network = this.buildSocialNetwork(pets);
    
    // ä¼ æ’­æƒ…ç»ª
    this.propagateEmotions(network);
    
    // å½¢æˆå°å›¢ä½“
    this.formCliques(network);
    
    // è§¦å‘ç¾¤ä½“äº‹ä»¶
    this.triggerGroupEvents(network);
  }
  
  /**
   * æƒ…ç»ªä¼ æŸ“
   */
  private propagateEmotions(network: SocialNetwork): void {
    for (const pet of network.nodes) {
      // è·å–æœ‹å‹çš„å¹³å‡æƒ…ç»ª
      const friends = network.getConnections(pet);
      const avgEmotion = this.averageEmotion(friends);
      
      // æœ‹å‹æƒ…ç»ªå½±å“è‡ªå·±ï¼ˆç¨‹åº¦å–å†³äºäº²å¯†åº¦ï¼‰
      pet.emotions.adjust(avgEmotion, 0.1);
    }
  }
}
```

### 8.3 åŠ¨æ€å™äº‹ç”Ÿæˆ

```typescript
/**
 * å™äº‹AIï¼ˆé«˜çº§åŠŸèƒ½ï¼‰
 */
class NarrativeAI {
  /**
   * ç”ŸæˆåŠ¨æ€æ•…äº‹
   * 
   * åŸºäºæ¡Œå® çš„ç»å†ç”Ÿæˆç‹¬ç‰¹çš„æ•…äº‹çº¿
   */
  public generateStory(pet: Pet): Story {
    // æå–å…³é”®è®°å¿†
    const keyMemories = pet.memorySystem.getKeyMemories();
    
    // è¯†åˆ«æ•…äº‹å¼§
    const arc = this.identifyStoryArc(keyMemories);
    
    // ç”Ÿæˆå™äº‹
    return this.constructNarrative(arc, pet);
  }
  
  /**
   * è¯†åˆ«æ•…äº‹å¼§
   */
  private identifyStoryArc(memories: Memory[]): StoryArc {
    // åˆ†ææƒ…æ„Ÿå˜åŒ–æ›²çº¿
    const emotionCurve = this.analyzeEmotionCurve(memories);
    
    // è¯†åˆ«è½¬æŠ˜ç‚¹
    const turningPoints = this.findTurningPoints(emotionCurve);
    
    // æ„å»ºæ•…äº‹ç»“æ„
    return {
      beginning: memories.slice(0, turningPoints[0]),
      rising: memories.slice(turningPoints[0], turningPoints[1]),
      climax: memories[turningPoints[1]],
      falling: memories.slice(turningPoints[1], turningPoints[2]),
      resolution: memories.slice(turningPoints[2])
    };
  }
}
```

---

## ä¹ã€æ€»ç»“ä¸æœ€ä½³å®è·µ

### 9.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **å¯è§£é‡Šæ€§ä¼˜å…ˆ**ï¼šç©å®¶éœ€è¦ç†è§£AIçš„è¡Œä¸ºåŠ¨æœº
   - âœ… ä½¿ç”¨æ•ˆç”¨ç†è®ºè€Œéé»‘ç›’ç¥ç»ç½‘ç»œ
   - âœ… æä¾›æ€è€ƒæ°”æ³¡å’Œå¯¹è¯è§£é‡Š
   - âœ… è°ƒè¯•æ¨¡å¼æ˜¾ç¤ºå†³ç­–æ¨ç†

2. **æ€§èƒ½ä¸å¤æ‚åº¦å¹³è¡¡**ï¼š
   - âœ… å¼‚æ­¥å†³ç­–é¿å…é˜»å¡ä¸»çº¿ç¨‹
   - âœ… ç¼“å­˜æœºåˆ¶å‡å°‘é‡å¤è®¡ç®—
   - âœ… LODç³»ç»Ÿæ ¹æ®é‡è¦æ€§è°ƒæ•´æ›´æ–°é¢‘ç‡

3. **è¡Œä¸ºå¤šæ ·æ€§**ï¼š
   - âœ… Softmaxé€‰æ‹©å¢åŠ éšæœºæ€§
   - âœ… æ¢ç´¢å¥–åŠ±é¿å…é‡å¤è¡Œä¸º
   - âœ… æ€§æ ¼å’Œç‰¹è´¨äº§ç”Ÿå·®å¼‚åŒ–

4. **ç³»ç»Ÿé›†æˆ**ï¼š
   - âœ… æ¸…æ™°çš„æ¥å£å®šä¹‰
   - âœ… æ¨¡å—åŒ–è®¾è®¡ä¾¿äºæ‰©å±•
   - âœ… ä¸æ¸¸æˆå…¶ä»–ç³»ç»Ÿè‰¯å¥½é…åˆ

### 9.2 å®ç°ä¼˜å…ˆçº§

**MVP v1.0**ï¼ˆå¿…é¡»ï¼‰ï¼š
- âœ… åŸºç¡€æ•ˆç”¨ç³»ç»Ÿ
- âœ… éœ€æ±‚é©±åŠ¨å†³ç­–
- âœ… ç®€å•è¡Œä¸ºæ ‘
- âœ… æ—¥å¸¸ç”Ÿæ´»AI

**MVP v1.5**ï¼ˆé‡è¦ï¼‰ï¼š
- âœ… æ€§æ ¼ç‰¹è´¨å½±å“
- âœ… æƒ…æ„Ÿç³»ç»Ÿé›†æˆ
- âœ… ç¤¾äº¤å…³ç³»å†³ç­–
- âœ… ä¾›å¥‰å†³ç­–AI

**MVP v2.0**ï¼ˆéœ€è¦ï¼‰ï¼š
- âœ… GOAPç›®æ ‡è§„åˆ’
- âœ… ä»»åŠ¡æ‰§è¡ŒAI
- âœ… å¤æ‚è¡Œä¸ºæ ‘
- âœ… è®°å¿†å½±å“å†³ç­–

**MVP v3.0+**ï¼ˆæƒ³è¦ï¼‰ï¼š
- â³ å­¦ä¹ å‹AI
- â³ ç¤¾äº¤ç½‘ç»œAI
- â³ å™äº‹ç”ŸæˆAI

### 9.3 å…³é”®æŠ€æœ¯æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | é‡è¦æ€§ |
|-----|-------|-------|
| å†³ç­–å»¶è¿Ÿ | <50ms | â­â­â­â­â­ |
| è¡Œä¸ºå¤šæ ·æ€§ | è¿ç»­é‡å¤<3æ¬¡ | â­â­â­â­ |
| ç©å®¶æ»¡æ„åº¦ | >80% | â­â­â­â­â­ |
| ç¼“å­˜å‘½ä¸­ç‡ | >80% | â­â­â­ |
| CPUå ç”¨ | <5% | â­â­â­â­ |
| å†…å­˜å ç”¨ | <100MB | â­â­â­ |

### 9.4 å¼€å‘å»ºè®®

1. **è¿­ä»£å¼€å‘**ï¼šå…ˆå®ç°ç®€å•AIï¼Œç¡®ä¿åŸºç¡€åŠŸèƒ½æ­£å¸¸ï¼Œå†é€æ­¥å¢åŠ å¤æ‚åº¦
2. **å……åˆ†æµ‹è¯•**ï¼šAIç³»ç»Ÿå®¹æ˜“äº§ç”Ÿæ„å¤–è¡Œä¸ºï¼Œéœ€è¦å¤§é‡æµ‹è¯•å’Œè°ƒæ•´
3. **æ•°å€¼è°ƒä¼˜**ï¼šæ•ˆç”¨æƒé‡ã€é˜ˆå€¼ç­‰éœ€è¦åå¤è°ƒæ•´æ‰èƒ½è¾¾åˆ°ç†æƒ³æ•ˆæœ
4. **å¯è§†åŒ–è°ƒè¯•**ï¼šå¼€å‘è°ƒè¯•å·¥å…·èƒ½æå¤§æå‡å¼€å‘æ•ˆç‡
5. **æ€§èƒ½ç›‘æ§**ï¼šæŒç»­ç›‘æ§AIæ€§èƒ½ï¼ŒåŠæ—¶å‘ç°ç“¶é¢ˆ

### 9.5 å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

| é™·é˜± | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|-----|------|---------|
| **å†³ç­–éœ‡è¡** | AIé¢‘ç¹åˆ‡æ¢è¡ŒåŠ¨ | å¢åŠ å†³ç­–ç²˜æ€§ï¼Œæ·»åŠ å†·å´æ—¶é—´ |
| **å±€éƒ¨æœ€ä¼˜** | AIé™·å…¥é‡å¤æ¨¡å¼ | å¢åŠ æ¢ç´¢å¥–åŠ±ï¼Œå¼•å…¥éšæœºæ€§ |
| **æ€§èƒ½é—®é¢˜** | AIè®¡ç®—è¿‡æ…¢ | å¼‚æ­¥å¤„ç†ï¼Œç¼“å­˜ï¼ŒLOD |
| **è¡Œä¸ºä¸åˆç†** | AIåšå‡ºå¥‡æ€ªå†³ç­– | æ·»åŠ çº¦æŸæ¡ä»¶ï¼Œè°ƒæ•´æƒé‡ |
| **ç¼ºä¹ä¸ªæ€§** | æ‰€æœ‰æ¡Œå® è¡Œä¸ºç›¸åŒ | å¼ºåŒ–æ€§æ ¼ç‰¹è´¨å½±å“ |

---

## é™„å½•Aï¼šå…³é”®ç®—æ³•ä¼ªä»£ç 

### A.1 ä¸»AIå¾ªç¯

```
function AI_Main_Loop(pet, worldState):
    // 1. æ„ŸçŸ¥
    perception = PerceptionSystem.perceive(pet, worldState)
    
    // 2. æ£€æŸ¥ç¼“å­˜
    cachedDecision = DecisionCache.get(pet, perception)
    if cachedDecision and isStillValid(cachedDecision):
        return cachedDecision
    
    // 3. å†³ç­–
    decision = DecisionSystem.makeDecision(perception)
    
    // 4. ç¼“å­˜
    DecisionCache.set(pet, perception, decision)
    
    // 5. æ‰§è¡Œ
    ExecutionSystem.execute(decision, pet)
    
    // 6. è¡¨ç°
    PresentationSystem.update(pet, decision)
    
    return decision
```

### A.2 æ•ˆç”¨è®¡ç®—ç®€åŒ–ç‰ˆ

```
function Calculate_Utility(action, perception):
    utility = 0
    
    // éœ€æ±‚æ•ˆç”¨
    for each need in perception.needs:
        if action.satisfies(need):
            urgency = (100 - need.value) / 100
            utility += action.needSatisfaction * urgency * 35
    
    // æ€§æ ¼æ•ˆç”¨
    for each trait in perception.traits:
        if action.matchesTrait(trait):
            utility += 15
    
    // ç›®æ ‡æ•ˆç”¨
    if action.contributesToGoal(perception.activeGoal):
        utility += 20
    
    return utility
```

---

## é™„å½•Bï¼šå‚è€ƒèµ„æ–™

### B.1 æ¨èé˜…è¯»

- **ã€ŠGame AI Proã€‹ç³»åˆ—** - æ¸¸æˆAIå¼€å‘å®è·µ
- **ã€ŠBehavioral Mathematics for Game AIã€‹** - æ•ˆç”¨ç†è®ºè¯¦è§£
- **ã€ŠProgramming Game AI by Exampleã€‹** - è¡Œä¸ºæ ‘å’ŒçŠ¶æ€æœº
- **ã€ŠAI Game Engine Programmingã€‹** - AIå¼•æ“æ¶æ„

### B.2 ç›¸å…³è®ºæ–‡

- *Utility-Based AI for Games* - Dave Mark
- *Goal-Oriented Action Planning* - Jeff Orkin 